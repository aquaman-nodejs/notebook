{"./":{"url":"./","title":"简介","keywords":"","body":" @media (min-width: 768px){ .markdown-section #book-cover { max-width: 80% !important; max-height: 460px; } } @media (max-width: 768px){ .markdown-section #book-cover { max-width: 100% !important; max-height: 460px; } } .book-anchor { display: none; } .page-inner { padding: 20px 40px 20px 40px; } [!note] [!tip] [!warning] [!danger] [!comment] [!question] "},"Foreword/":{"url":"Foreword/","title":"序言","keywords":"","body":" 前言 Node.js 学习教程，主要讲解 JS 语言、Node.js 框架、前后端开发、数据库、消息队列、监控、桌面应用和运维部署等内容，帮助初学者更好的学习 Node.js 开发。 关于作者 松露 🎓 华东师范大学软件工程硕士 📡 信息系统项目管理工程师 👨‍💻 腾讯课堂认证老师 🌍 个人主页 星河 🎓 郑州大学计算机科学与技术专业 📡 系统架构师 🌍 个人主页 所有内容均为以上作者整理发布。如有错误，欢迎指正。 版权说明 本项目采用 MIT License 进行许可。未经作者授权，请勿用于商业用途！ "},"Chapter1/":{"url":"Chapter1/","title":"第一章 JS 语法","keywords":"","body":" JS 语法 JavaScript 是属于 HTML 和 Web 的编程语言，编程令计算机完成您需要它们做的工作。JavaScript 很容易学习。本篇章涵盖 JavaScript 基础和进阶教程。 一、JS 基础 二、JS 进阶 "},"Chapter1/1.html":{"url":"Chapter1/1.html","title":"一、JS 基础","keywords":"","body":"JS 基础 JavaScript 是 Web 的编程语言。 所有现代的 HTML 页面都使用 JavaScript。 JavaScript 非常容易学。 数据类型 基本类型 引用类型 ● 字符串 String● 数字 Number● 布尔 Boolean● 对空 Null● 未定义 Undefined●Symbol ● 对象 Object● 数组 Array● 函数 Function● 日期 Date● 正则 RegExp [!note] Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 typeof JavaScript 是一门弱语言，它在声明变量时无需确定变量的类型，JavaScript 在运行时会自动判断。 那么如何判断一个变量的类型呢？JavaScript 提供了typeof运算符，用来检测一个变量的类型。 使用方法 typeof 表达式; // 或 typeof 变量; 返回值 示例 返回值 说明 typeof undefined \"undefined\" 未定义的变量或值 typeof true \"boolean\" 布尔类型 typeof \"123\" \"string\" 字符串 typeof 123 \"number\" 数值 typeof []typeof {} \"object\" null 值数组JS 对象 typeof console.logtypeof function(){} \"function\" 函数 动态类型 JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型： var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = 'John'; // 现在 x 为字符串 Undefined 和 Null Undefined：表示变量“缺少值”，即这地方应该有值，但是目前还没有定义值。 Null：表示变量有值，值为“空”。可以通过将变量的值设置为 null 来清空变量。 undefined == null; // true undefined === null; // false typeof undefined; // \"undefined\" typeof null; // \"object\" Number(undefined); // NaN Number(null); // 0 变量提升 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 以下两个实例将获得相同的结果： // 实例1 x = 5; // 变量 x 设置为 5 elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x; // 在元素中显示 x var x; // 声明 x // 实例2 var x; // 声明 x x = 5; // 变量 x 设置为 5 elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x; // 在元素中显示 x JavaScript 只有声明的变量会提升，初始化的不会。 以下两个实例结果结果不相同： // 实例1 var x = 5; // 初始化 x var y = 7; // 初始化 y elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x + ' ' + y; // 显示 x 和 y // 实例2 var x = 5; // 初始化 x elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x + ' ' + y; // 显示 x 和 y，y 为 undefined var y = 7; // 初始化 y 变量定义 var 的 bug Js 没有块级作用域。 请看这样一条规则：在 JS 函数中的 var 声明，其作用域是函数体的全部。 // 明明已经跳出 for 循环了，却还可以访问到 for 循环内定义的变量 a ，甚至连 i 都可以被放访问到，尴尬~ for (var i = 0; i 循环内变量过度共享。 在浏览器里运行一下，看看和你预想的结果是否相同？ 没错，控制台输出了 3 个 3，而不是预想的 0、1、2。 事实上，这个问题的答案是，循环本身及三次 timeout 回调均共享唯一的变量 i 。 当循环结束执行时，i 的值为 3。所以当第一个 timeout 执行时，调用的i 当让也为 3 了。 for (var i = 0; i 话说到这儿，想必客官已经猜到 let 是干嘛用的。 你没猜错，就是解决这两个 bug 的。 你尽可以把上述的两个例子中的 var 替代成 let 再运行一次。 [!node] 必须声明 'use strict' 后才能使用 let 声明变量，否则浏览并不能显示结果。 let 定义变量 let 声明的变量拥有块级作用域。 let 声明的全局变量不是全局对象的属性。 形如 for (let x...)的循环在每次迭代时都为 x 创建新的绑定。 用 let 重定义变量会抛出一个语法错误（SyntaxError）。 let a = 'a'; let a = 'b'; // Uncaught SyntaxError: Identifier 'a' has already been declared const 定义常量 ES6 引入的第三个声明类关键词：const。const 就是用来定义常量的。 // 下面程序会报错 // a是一个常量，不能被赋值。 const a = 1; a = 2; // Uncaught TypeError: Assignment to constant variable. // 下面程序却不会报错 // a虽然是常量，但是一个对象，存的是地址不是值 const a = {}; a['key'] = 'value'; 对象 JavaScript 对象是拥有属性和方法的数据。 生活中，一辆汽车是一个对象。 对象有它的属性，如重量和颜色等，方法有启动停止等。 [!note] 在 JavaScript 中，对象是非常重要的，当你理解了对象，就可以了解 JavaScript 。 JavaScript 对象是变量的容器。 var person = { firstName: 'John', lastName: 'Doe', fullName: function () { return this.firstName + ' ' + this.lastName; }, }; person.fullName(); // 返回 John Doe String 字符串对象 JavaScript 字符串是原始值，可以使用字符创建： var firstName = \"John\" 但我们也可以使用 new 关键字将字符串定义为一个对象： var firstName = new String(\"John\") var x = 'John'; var y = new String('John'); typeof x; // \"string\" typeof y; // \"object\" [!danger] 不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用。 Number 数字对象 var x = 1; var y = new String(1); typeof x; // \"number\" typeof y; // \"object\" Date 日期对象 const now = new Date(); // Sun Mar 28 2021 16:15:47 GMT+0800 (中国标准时间) now.getFullYear(); // 年 2021 now.getMonth(); // 月 2 从0开始index，2index表示3月 now.getDate(); // 日 28 now.getDay(); // 星期 0 从0开始，星期天是0 now.getHours(); // 时 16 now.getMinutes(); // 分 15 now.getSeconds(); // 秒 47 now.getMilliseconds(); //毫秒 498 Array 数组对象 常用对象方法。 方法 描述 concat() 连接 2 个及以上的数组，返回新的数组 copyWithin(2, 0) index2 赋值为 index0index3 赋值为 index1 every() 检测数组所有元素是否都符合指定条件（通过函数提供）。返回 true、false fill(value, start, end) 用一个固定值，从 start 开始到 end 截止填充 findIndex() 返回符合条件的第一个元素的 index lastIndexOf() 返回符合条件的最后一个元素的 index find() 返回符合条件的第一个元素 filter() 返回符合条件的所有元素 indexOf() 某值在数组中的 index不存在为-1 join(separator) 数组合并为字符串，用separator分隔符连接 shift() 删除数组的第一个元素并返回删除的元素 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 数组反转 slice() 截取一部分，返回新数组 Boolean 布尔对象 Boolean（布尔）对象用于将非布尔值转换为布尔值（true 或者 false）。 // false 相等的几种情况 0 == false; // true -0 == false; // true '' == false; // true // false 不等的几种情况 undefined == false; // false NaN == false; // false null == false; // false Math 算术对象 属性 描述 Math.PI 返回圆周率（约等于 3.14159） Math.E 返回算术常量 e，即自然对数的底数（约等于 2.718） LN10 返回 10 的自然对数（约等于 2.302） LN2 返回 2 的自然对数（约等于 0.693） 对象 描述 Math.abs(x) x 的绝对值 Math.random() 0~1 之间的数 Math.ceil(x) 向上取整 Math.floor(x) 向下取整 Math.round(x) 四舍五入 Math.sqrt(x) 计算平方根 Math.max(x1, x2,...,xn) 最大值 Math.min(x1, x2,...,xn) 最小值 Math.pow(x,y) x 的 y 次方 RegExp 正则对象 // 下面两个是等价的 var re1 = new RegExp('\\\\w+'); var re2 = /\\w+/; Error 错误对象 Error 对象在错误发生时提供了错误的提示信息。 运行时错误实例会由执行引擎自动创建和抛出，我们也可以通过构造函数自定义Error实例，与其它类一样我们也可以通过Error.prototype向实例中添加属性和方法。 Error实例包含以下属性或方法： Error.prototype.constructor － 指定对象的构造函数 Error.prototype.message － 错误信息 Error.prototype.name － 错误名 Error.prototype.stack － 错误堆栈信息。该属性是一个非标准属性，但被大多数执行引擎所支持。 Error.prototype.toString() － 表示错误对象的描述信息。继承并重写Object.prototype.toString() 错误类型： EvalError ：Eval 错误，对象表示全局函数eval()中发生的错误。 ReferenceError：引用错误，错误对象会在引用未定义的变量时触发。 RangeError：范围错误，错误对象会在值超过有效范围时触发。 SyntaxError：语法错误，错误对象会使用不合法的语法结构时触发。 TypeError：类型错误，错误会在对象用来表示值的类型非预期类型时触发。 URIError：URI 错误，错误会错误使用全局 URI 函数如encodeURI()、decodeURI()等时触发 this 关键字 面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象。 开发规范 代码规范 通用性 代码和 bug 总是形影不离的。减少 bug 的最好方式就是减少代码本身。用更少的代码完成同样的任务迫使你投入更多的时间思考和设计。更少的代码更易于维护，因为你要读的代码更少。更少的代码还带来了一致性。想象一下如果同样的逻辑在 3 处重复了 3 遍，当你修改时你可能只改了 1 处，不一致就产生了。 关于重用性有一种思想误区：库的代码才需要有重用性，我的代码不需要，因为没人会重用我的代码。重用性是一种写代码时的思考方式，应该成为一种写代码的习惯。就算没有别人会重用你的代码，你自己也要重用你的代码。 职责划分清楚 为了使代码具备重用性，很重要的一个因素就是职责划分。通俗一点讲就是“管好你该管的事，不要管你不该管的事”。如果一段代码的职责是调用发送邮件，那它就做好这件事。至于使用这个 api 的人是谁，在什么场景使用，都不是这个 api 该管的事。如果一个功能需要 300 行代码来完成，我们该如何去划分职责？又该如何去把这些代码归类放到哪些函数/类/文件中呢？这时候你就要在脑中形成几个各自独立的模块，把功能相关的代码聚到一起放在一个模块中。同时还要思考模块之间的接口如何定义。比如我们要处理一个商品被购买后发货的处理。这时你大概就可以在脑中模糊地形成这么几个模块：商品、订单、支付、物流。然后再去细想各个模块的职责边界在哪。模块之间的交互是怎样的。如果商品模块里有订单的内部逻辑代码，然后订单模块里有顺丰物流的 api 细节。很快你就会发现这些模块很难被重用了。 代码分层 任何复杂的事情都是通过分层来降低认知和管理的难度。国家分为省、市、区、镇。学校按照年级和班级划分。写文章也要有开头、中间和收尾，每一部分又可以再分几个步骤。互联网分了 4 层，各司其职，应用层不用去担心物理层。写代码也是一样。逻辑是要一层一层展开，而不是 500 行代码平铺在一个函数里。 可读性 代码的可读，有个硬性的规定，就是每个功能函数的行数不宜过多，一方面要保证函数的结构紧凑，另一方面也便于后期的单元测试。 避免多次 callback 回调或多次嵌套 if 判断 callback 由于 async 和 promise 的使用，callbck hell 出现的情况不太多。但是，if 的多层判断，一定会经常的出现，所以，做判断的时候，要注意，不要一直嵌套嵌套 if，这样代码 review 很费力很费力。 if (a) { if (b) { if (c) { // 需要执行的方法A(缩进太多，review起来真费劲 o(╥﹏╥)o ) } } } if (!a || !b || !c) { return; } // 需要执行的方法A(没缩进，review起来真舒服 ^_^ ) 正确性 不要用 any 类型 众所周知，js 是灵活的弱类型语言，我们永远无法确定一个变量的实际类型，这在开发的时候也就造成了一定的“恐慌”，比如： if (typeof a === \"string\") if (Array.isArray(a) && a.length > 0) if (a) if (!a) if (a != NaN) 自从 ts 出现以后，一切都变得奇迹。ts 具有类型系统，且是 js 的超集。比如，我用 ts 定义了一个变量是 string 类型，那么就不能把 number 类型的值赋值给他。但是，ts 也有一个漏洞，就是 any 类型，比如下面这个例子。 const anyThing:any = { name: string age?: number } 虽然 name 是 string 类型，但是 anyThing 不是啊，这个就尴尬了，这样的话，name 是有可能为任何值的。所以，尽量少用 any（除非迫不得己）。因为每增加一个 any，代码就增加了一份风险和恐慌。 变量定义的使用顺序 const > let，减少使用 var js 有一个很恐怖的事情就是“变量提升”，就是 js 引擎在解析代码的时候，先把 var 定义和函数定义提到最前面去，这就是所谓的“变量提升”和“函数提升”。而且，var 是全局变量，看下面一个经典的错误案例。 var a = 99; // 全局变量a f(); // f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 console.log(a); // a=>99, 此时是全局变量的a function f() { console.log(a); // 当前的a变量是下面变量a声明提升后，默认值undefined var a = 10; console.log(a); // a => 10，这个a是上一行赋值的 } let 和 const 是 ES6 新增的定义类型 let 是不会变量提升的，而且有暂时性死区。也就是 let 必须先声明，后面的代码才能够使用，否则 Uncaught ReferenceError 错误。 const 只能够初始化赋值，相当于是定义一个常量，但是 const 定义的常量对于数组和对象无法控制。 命名规范 文件命名 对于文件，由于早期 Windows 操作系统不区分文件名大小写，所以文件尽可能以小写形式命名，多个单词中间使用连字符“-”连接。 变量命名 变量命名全部采用“小驼峰式(lowerCamelCase)”。当一段代码很长的时候要把它拆分然后用函数或变量给予有意义的名称。我们人脑喜欢看人类语言，而不是程序语言。所以我们写的代码要尽可能像英语，而不是编程语言。 命名时要注意动词、名词和形容词的区分。动词来代表一个指令动作，名词代表一个对象名称，形容词来表示一个状态（往往是 boolean 或 enum）。一般来说，函数命名使用动词形式，变量命名使用名词或形容词形式。 举例： 动词：login addUser getUserInfo 名词：user 形容词：isUser 命名参考(Java) 类名：UpperCamelCase（大驼峰命名法） 方法名、参数名、局部变量名：lowerCamelCase（小驼峰命名法） 测试方法名、常量(全局)、枚举名称：SNAKE_CASE（蛇形命名法） 文件夹名称：kebab-case（串式命名法） 开发工具和插件 Prettier 插件 function 后面是否加空格？ 括号是否要换行？ 结尾加分号还是不加分号？ 用单引号还是双引号？ 一千个程序员就会有一千种代码风格。当我们团队协作开发时候，我们要“舍弃”自己的特色，而统一风格，否则，对于其他开发人员来说，另类的代码风格是很不友好的体现。举一个简单的例子，下面三种代码风格，每一种都有自己的特色。 // 普通程序员 function main() { let a = 0, b = 1, c = 2; return 0; } // 文艺程序员 function main() { let a = 0; let b = 1; let c = 2; return 0; } // 2B程序员 function main() { let a = 0, b = 1, c = 2; return 0; } Prettier 就是用来帮助我们统一代码风格的工具。 "},"Chapter1/2.html":{"url":"Chapter1/2.html","title":"二、JS 高级","keywords":"","body":"JS 进阶 面向对象编程 什么是对象？万物皆对象。 在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。 自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 面向过程 & 面向对象 我们以一个示例来说明两者区别。 我们需要处理学生成绩，将学生的成绩打印出来。 首先，面向过程编程的方式是这样的。 // 面向过程编程 // 1. 存储学生成绩信息 var std1 = { name: '张三', score: 98 }; var std2 = { name: '李四', score: 81 }; // 2. 输出学生成绩 function printScore(student) { console.log('姓名：' + student.name + ' ' + '成绩：' + student.score); } 面向对象编程，考虑的不是程序执行流程，而是 Student 这个对象有哪些属性和方法。 // 面向对象编程 // 1. 定义对象（类） function Student(name, score) { this.name = name; this.score = score; } Student.prototype.printScore = function () { console.log('姓名：' + this.name + ' ' + '成绩：' + this.score); }; // 2. 实例化对象 var std1 = new Student('张三', 98); var std2 = new Student('李四', 81); // 3. 输出学生成绩 std1.printScore(); // => 姓名：张三 成绩：98 std2.printScore(); // => 姓名：李四 成绩 81 如何创建对象 字面量方式 我们可以直接通过 new Object() 创建。 var person = new Object(); person.name = '张三'; person.age = 18; person.sayName = function () { console.log(this.name); }; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建。 var person = { name: '张三', age: 18, sayName: function () { console.log(this.name); }, }; 上面的写法是没有问题的，但是假如我们要生成两个 person 实例对象呢？ var person1 = { name: '张三', age: 18, sayName: function () { console.log(this.name); }, }; var person2 = { name: '李四', age: 16, sayName: function () { console.log(this.name); }, }; 工厂模式 function createPerson(name, age) { return { name: name, age: age, sayName: function () { console.log(this.name); }, }; } var p1 = createPerson('张三', 18); var p2 = createPerson('李四', 18); 这样封装比上边的方式好多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题， 但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数创建对象 创建对象的最佳实践方案，则是利用构造函数。 所谓的构造函数其实就是一个普通的函数前面加了 new 运算符，其实质也是一个函数，所以构造函数都有函数的 prototype 属性。 实例就是通过构造函数创建出来的对象。 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; } var p1 = new Person('张三', 18); p1.sayName(); // => 张三 var p2 = new Person('李四', 23); p2.sayName(); // => 李四 构造函数特点 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 构造函数执行步骤 使用 new 操作符创建一个新对象。 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）。 执行构造函数中的代码。 返回新对象。 // 伪代码演示 function Person(name, age) { // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = {} // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; // 在函数的结尾处会将 this 返回，也就是 instance // return this } 构造函数示例 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; } var p1 = new Person('张三', 18); p1.sayName(); // => 张三 var p2 = new Person('李四', 23); p2.sayName(); // => 李四 console.log(p1.constructor === Person); // 变量p1的构造器是Person，返回true console.log(p2.constructor === Person); // 变量p2的构造器是Person，返回true console.log(p1.constructor === p2.constructor); // 变量p1和p2的构造器相同 console.log(p1 instanceof Person); // 返回 true console.log(p2 instanceof Person); // 返回 true 上边的代码，从表面看上好像没什么问题，但是实际上这样做，有一个很大的弊端。 那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容， 每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 function Person(name, age) { this.name = name; this.age = age; this.type = '学生'; this.sayHello = function () { console.log('hello ' + this.name); }; } var p1 = new Person('王五', 18); var p2 = new Person('李四', 16); console.log(p1.sayHello === p2.sayHello); // => false 有什么好的解决办法呢？更好的解决方案就是 prototype。 Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。 这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 function Person(name, age) { this.name = name; this.age = age; } console.log(Person.prototype); // 返回 { constructor:{...}, _proto_:{...} } Person.prototype.type = '学生'; Person.prototype.sayName = function () { console.log(this.name); }; var p1 = new Person('王五', 18); var p2 = new Person('李四', 16); console.log(p1.sayName === p2.sayName); // => true 这时所有实例的 type 属性和 sayName() 方法， 其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 原型和原型链 原型 原型的作用：数据共享、节省内存。 所谓的构造函数其实就是一个普通的函数前面加了 new 运算符，其实质也是一个函数，所以构造函数都有函数的 prototype 属性。实例就是通过构造函数创建出来的对象。 prototype 属性是一个指针，指向一个对象，这个对象就是原型对象。 至于是谁的原型对象，需要靠函数的 prototype 属性和实例的__proto__属性来确定。 原型对象上默认有一个属性 constructor,该属性也是一个指针，指向其相关联的构造函数。 function People() { this.type = '人'; } People.prototype.showType = function () { console.log(this.type); }; var person = new People(); //调用原型对象上面的方法 person.showType(); //最后结果弹框弹出人 People.prototype.constructor == People; //返回true [!note] 构造函数的 prototype 是指针，指向的是原型对象。 原型对象的 constructor 也是指针，指向的是构造函数。 实例的_proto_指针也指向原型对象。 原型链 从实例开始，实例的_proto_指针指向原型对象，原型对象也存在_proto_指针指向上一层的原型对象。后面也以此类推，一直到 Object.prototype 这个原型为止，Object.prototype 为原型链的末尾点。 function People() { this.name = 'Jane'; } var person = new People(); [!note] person 实例的_proto_属性指向原型对象 原型对象的_proto_指向上一层 Object 原型对象。 Object 原型对象的构造函数是 Object，为该原型链的末端。 instanceof 的原理 instanceof 可以判断实例对象的_proto_属性是否与构造函数的 prototype 属性指向同一地址，是的话返回 true，否则 fasle。 // 实例 instanceof 构造函数 person instanceof People; constructor 构造器 实例的_proto_属性找到原型对象，原型对象的 constructor 属性找到构造函数。 person._proto_.constructor == People; 更简单的原型语法 function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { type: '学生', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了'); }, }; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。 这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { constructor: Person, // => 手动将 constructor 指向正确的构造函数 type: '学生', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了'); }, }; 原生对象(String/Array...)的原型 // 为内置对象添加原型方法 // 我们在系统的对象的原型中添加方法,相当于在改变源码 // 我希望字符串中有一个倒序字符串的方法 String.prototype.myReverse = function () { for (var i = this.length - 1; i >= 0; i--) { console.log(this[i]); } }; var str = 'abcdefg'; str.myReverse(); // 为Array内置对象的原型对象中添加方法 Array.prototype.mySort = function () { for (var i = 0; i 继承 继承是一种类(class)与类之间的关系,JS 中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承，继承是为了实现数据共享，js 中的继承当然也是为了实现数据共享。 原型继承 function Person(name, age, sex, weight) { this.name = name; this.age = age; this.sex = sex; this.weight = weight; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(score) { this.score = score; } //希望人的类别中的数据可以共享给学生---继承 Student.prototype = new Person('小三', 18, '男', '58kg'); var stu1 = new Student('99'); console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score); stu1.sayHi(); var stu2 = new Student('89'); console.log(stu2.name, stu2.age, stu2.sex, stu2.weight, stu2.score); stu2.sayHi(); var stu3 = new Student('66'); console.log(stu3.name, stu3.age, stu3.sex, stu3.weight, stu3.score); stu3.sayHi(); 构造函数继承 在上边的讲解中，我们为了数据共享,改变了原型指向,做到了继承，即通过改变原型指向实现了继承。这导致了一个问题，因为我们改变原型指向的同时,直接初始化了属性，这样继承过来的属性的值都是一样的了。这是个问题，如果我们想要改变继承过来的值，只能重新调用对象的属性进行重新赋值，这又导致我们上边的初始化失去了意义。 如何解决上边的问题呢？答案是借用构造函数实现继承。 继承的时候,不改变原型的指向,直接调用父级的构造函数来为属性赋值，即把要继承的父级的构造函数拿过来,借用一下为属性赋值，这叫做借用构造函数。借用构造函数需要使用 call ()这个方法，我会在后边的文章中进行讲解，大家在这里先记住用法就行了。 function Person(name, age, sex, weight) { this.name = name; this.age = age; this.sex = sex; this.weight = weight; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(name, age, sex, weight, score) { // ☆☆☆ 借用构造函数 ☆☆☆ Person.call(this, name, age, sex, weight); this.score = score; } var stu1 = new Student('小三', 16, '男', '50kg', '110'); console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score); var stu2 = new Student('小红', 22, '女', '45kg', '88'); console.log(stu2.name, stu2.age, stu2.sex, stu2.weight, stu2.score); var stu3 = new Student('小舞', 16, '女', '40kg', '100'); console.log(stu3.name, stu3.age, stu3.sex, stu3.weight, stu3.score); 借用构造函数继承,解决了继承的时候属性重复的问题。但是这又导致一个问题即父类中的原型方法不能被继承。 组合继承 原型继承和借用构造函数继承都存在各自的缺点，我们可以将这二者结合到一起，从而发挥二者之长。即在继承过程中，既可以保证每个实例都有它自己的属性，又能做到对一些属性和方法的复用。 这时组合继承应运而生，组合继承=原型继承+构造函数继承。 function Person(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(name, age, sex, score) { //借用构造函数:解决属性值重复的问题 Person.call(this, name, age, sex); this.score = score; } //改变原型指向---原型继承解决原型方法不能被继承问题 Student.prototype = new Person(); //不传值 Student.prototype.eat = function () { console.log('吃吃吃!!!'); }; var stu = new Student('小三', 16, '男', '111分'); console.log(stu.name, stu.age, stu.sex, stu.score); stu.sayHi(); stu.eat(); var stu2 = new Student('小舞', 15, '女', '1111分'); console.log(stu2.name, stu2.age, stu2.sex, stu2.score); stu2.sayHi(); stu2.eat(); 拷贝继承（for-in） 拷贝继承：把一个对象中的属性或者方法直接复制到另一个对象中。 function Person() {} Person.prototype.name = '小三'; Person.prototype.age = 18; Person.prototype.sex = '男'; Person.prototype.height = 100; Person.prototype.play = function () { console.log('玩的好开心呀!!!😃'); }; var obj = {}; // Person中有原型prototype,prototype就是一个对象,那么里面,name,age,sex,height,play都是该对象中的属性或者方法 // 新对象obj通过拷贝Person中原型prototype对象中的属性和方法继承Person中原型prototype对象的属性和方法 for (var key in Person.prototype) { obj[key] = Person.prototype[key]; } console.dir(obj); obj.play(); [!note] 原型链是一种关系,是实例对象和原型对象之间的关系,这种关系是通过原型(proto)来联系的。继承是类与类之间的关系，js 不是面向对象的语言，没有类但可以通过函数模拟类，模拟面向对象中的继承。模拟继承是为了实现数据共享，节省内存空间。 JS 中的继承方式: 原型继承:通过改变原型的指向实现继承。 借用构造函数继承:主要解决属性重复的问题，会导致父类中的原型方法不能继承。 组合继承:原型继承+借用构造函数继承，既能解决属性重复问题,又能解决方法不能被继承的问题。 拷贝继承:把对象中需要共享的属性或方法,直接通过遍历的方式复制到另一个对象中。 函数 函数声明 直接声明 变量声明 Function 构造函数创建实例（❌） // 直接声明 function fn() { console.log('我是JS中的一等公民-函数!!!哈哈'); } fn(); // 变量声明 var fn = function () { console.log('我是JS中的一等公民-函数!!!哈哈'); }; fn(); // Function构造函数创建实例 // new Function(arg1,arg2,arg3..,函数体); var f1 = new Function('num1', 'num2', 'return num1+num2'); console.log(f1(10, 20)); console.log(f1.__proto__ == Function.prototype); // 所以,函数实际上也是对象 console.dir(f1); console.dir(Function); 函数调用 普通函数 构造函数 对象方法 // 普通函数 function f1() { console.log('我是普通函数'); } f1(); // 构造函数---通过new 来调用,创建对象 function F1() { console.log('我是构造函数'); } var f = new F1(); // 对象的方法 function Person() { this.play = function () { console.log('我是对象中的方法'); }; } var per = new Person(); per.play(); this 指向 函数的调用方式决定了 this 指向的不同 调用方式 浏览器 Node.js 全局 this window {} 实际是 module 函数中的 this undefined（严格模式）window（非严格模式） 全局 global 构造函数中的 this 实例对象 实例对象 定时器函数 window Timeout // 普通函数 function f1() { console.log(this); // window | 严格模式下undefined } f1(); // 构造函数 function Person() { console.log(this); // Person // 对象的方法 this.sayHi = function () { console.log(this); // Person }; } // 定时器中的this setInterval(function () { console.log(this); // window }, 1000); call 和 apply call()和apply()作为函数调用，可以改变 this 的指向。 [!note] call( 指定this, [参数数组] ) apply( 指定this, 参数1, 参数2 ... ) function Person(name, sex) { this.name = name; this.sex = sex; } //通过原型添加方法 Person.prototype.sayHi = function (x, y) { console.log('您好啊:' + this.name); return x + y; }; var per = new Person('小丽', '男'); var r1 = per.sayHi(10, 20); // 构造函数的this，为实例per function Student(name, age) { this.name = name; this.age = age; } var stu = new Student('小王', 18); var r2 = per.sayHi.apply(stu, [10, 20]); // this指向stu var r3 = per.sayHi.call(stu, 10, 20); // this指向stu console.log(r1); console.log(r2); console.log(r3); 如果想使用别的对象的方法，并且希望这个方法是当前对象的，就可以使用 apply 或者是 call 方法改变 this 的指向。 bind bind()方法是绑定的意思，本质是创建一个新函数（成为”绑定函数“），参数可以在复制的时候传进去，也可以在复制之后调用的时候传入进去。 bind()方法，是复制一份的时候，改变了 this 的指向。 function Person(name) { this.name = name; } Person.prototype.play = function () { console.log(this + '====>' + this.name); }; function Student(name) { this.name = name; } var per = new Person('人'); var stu = new Student('学生'); per.play(); // 复制了一个新的play方法 var ff = per.play.bind(stu); ff(); [!note] 函数是对象，对象不一定是函数。 对象中有_proto_属性，函数中有 prototype 属性。 apply，call，bind 方法是用来改变 this 指向的。 apply 和 call 是调用方法的时候改变 this 指向。 bind 方法是创建一个新的函数的时候改变 this 的指向。 内存 内存存储 JS 分为两种类型，基本类型和引用类型。 基本类型 引用类型 ● 字符串 String● 数字 Number● 布尔 Boolean● 对空 Null● 未定义 Undefined●Symbol ● 对象 Object● 数组 Array● 函数 Function● 日期 Date● 正则 RegExp 栈内存和堆内存 栈内存：存储基本类型的变量值和引用类型的变量值地址。 堆内存：存储引用类型的变量值。 const num = 1; const obj = { key: 'val', }; num = 2; // TypeError: Assignment to constant variable. obj.key = 'val1'; // 赋值成功 num 和 null_val 两个变量都是基本类型，所以，直接在栈内存中存储值。 obj 是引用类型，在栈内存中存储地址，堆内存中存储值。 [!note] null 虽然是 object 类型，但是仍然存储在栈内存中。 obj 虽然是 const 定义，但是其存储的是指针地址，这个地址不可以改变，但是地址对应的堆内存中的数据，是可以改变的。所以 obj.key 仍然可以改变其值。 所以，const 定义的变量其值不可以改变这个说法不准确。 new 定义的基本类型 new 一个构造函数，构造函数生成一个实例，这个实例是一个对象。 JS 提供了一些基本类型的构造函数，比如，String\\Number 等，那么这些 new 出来的变量和正常定义的变量有何不同呢？ 虽然，他们表面上看起来没什么区别，实际上内部完全不同。 new 出来的变量是一个对象，对象就是引用类型，栈内存中存储的是地址。 正常定义的变量就是一个基本类型变量，栈内存中存储的是变量值。 const str1 = 'hello'; const str2 = new String('hello'); const str3 = new String('hello'); console.log(str1 == str2); // true console.log(str2 == str3); // false console.log(str1 === str2); // false str1 和 str2 虽然表面一样，但是类型不同，所以弱等于（==）是相等的，强等于（===）是不等的。 str2 和 str3 虽然都是 object，但是是通过 new 出来的，他们都是对象，那么存储的就是地址。所以，str2 的地址不等于 str3 的地址。 [!danger] 不建议大家使用 new 来定义基本类型。 深拷贝 & 浅拷贝 不同类型的复制变量值的方式是不同的。对于基本类型，从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量。对于引用类型，从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量都指向同一个对象。 浅拷贝 浅拷贝就是直接复制，相当于把一个对象中的所有的内容，复制一份给另一个对象，对于基本类型复制的是具体的值的副本，对于引用类型复制的是指针。 const obj1 = { key: 'val' }; const obj2 = obj1; // 浅拷贝，obj1和obj2的值会互相影响 深拷贝 深拷贝还是复制，对于基本类型复制的是具体的值的副本，对于引用类型会找到对象中具体的属性或者方法，并且开辟新的相应的空间，一个一个的复制到另一个对象中，在这个过程中需要使用递归。 function deepCopy = { // ...... } const obj1 = { key: 'val' }; const obj2 = deepCopy(obj1); // 深拷贝 深拷贝实现 第三方库 浏览器端使用 jQuery.extend 实现。 Node.js 环境使用 lodash 库实现。 // 浏览器 jQuery.extend $.extend(true, object1, object2); // 深度拷贝 $.extend(object1, object2); // 浅拷贝 // Node.js环境 lodash 库 var objects = [{ a: 1 }, { b: 2 }]; var deep = _.cloneDeep(objects); console.log(deep[0] === objects[0]); // => false JSON 对象 如果是一个 Object 对象或数组实现深拷贝，可以用JSON.stringify()和JSON.parse()来实现深拷贝。 var obj1 = { name: 'shen', }; var obj2 = JSON.parse(JSON.stringify(obj1)); obj2.name = 'shenzhiyong'; console.log('obj1:', obj1); // obj1: {name: \"shen\"} console.log('obj2:', obj2); // obj2: {name: \"shenzhiyong\"} 如果对象中有函数，则该方法不可用。 var obj1 = { name: 'shen', show: function (argument) { console.log(1); }, }; var obj2 = JSON.parse(JSON.stringify(obj1)); console.log('obj1:', obj1); // obj1: {name: \"shen\", show: ƒ} console.log('obj2:', obj2); // obj2: {name: \"shen\"} // show没有拷贝过来 递归实现 递归简单的来说就是程序自己调用自己，就像下面这幅图一样，一直循环往复。 就像我们经常听到的小和尚的故事，从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里...... JavaScript 的递归就是在函数中调用函数自己。 // 递归:函数中调用函数自己 function f1() { console.log( '从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：' ); f1(); // 调用自己 } f1(); 如果程序一直这样循环往复的调用自己，一直都不结束，就是一个死循环，这没什么意义。 所以我们需要为递归定义一个结束条件，即递归的出口，当条件不满足时，递归一直前进，不断地调用自己；当边界条件满足时，递归返回。 // 递归的结束条件为i大于5 var i = 0; function f1() { i++; if (i > 5) { return; // 出口 } console.log( '从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：' ); f1(); } f1(); 递归深拷贝代码 function deepCopy(obj) { // 简单类型 或 null 直接返回 if (typeof obj !== 'object' || obj === null) { return obj; } const newObj = obj.constructor === Array ? [] : {}; // 循环 obj 的属性/元素 for (const key in obj) { const val = obj[key]; if (typeof val !== 'object' || val === null) { newObj[key] = val; } else { newObj[key] = deepCopy(val); } } return newObj; } var obj1 = { name: 'shen', show: function () { console.log('hello world'); }, }; var obj2 = deepCopy(obj1); console.log('obj1:', obj1); // obj1: { name: 'shen', show: [Function: show] } console.log('obj2:', obj2); // obj2: { name: 'shen', show: [Function: show] } 闭包 作用域 变量分为全局变量和局部变量。作用域也就是变量的使用范围，分为全局作用域和局部作用域。 局部变量的使用范围为局部作用域，全局变量的使用范围是全局作用域。 在 ES6 引入了let定义变量后，也增加了一个块级作用域。 作用域链 内部函数访问外部函数的变量时，采用的是链式查找的方式。从里向外搜索，如果中间搜到了就使用，搜到 0 级作用域还没有搜到则报错，这个过程就是作用域链。 // 作用域链:变量的使用,从里向外,层层的搜索,搜索到了就直接使用 // 搜索到0级作用域的时候,如果还是没有找到这个变量,就会报错 const num1 = 10; //作用域链 function f1() { const num2 = 20; function f2() { const num3 = 30; console.log(num1); // >10 } f2(); } f1(); 预解析 JS 代码在浏览器中是由 JS 引擎进行解析执行的，分为两步，预解析和代码执行。 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升），浏览器 JS 代码运行之前，会把变量的声明和函数的声明提前(提升)到该作用域的最上面。 变量预解析 把所有变量的声明提升到当前作用域的最前面，不提升赋值操作。 下面是预解析前编写的代码。 // 原始代码 console.log(num); // 没有报错，返回的是一个undefined var num = 666; 预解析后，num 变量声明提升到最前面，但是赋值操作仍在后面。 // 预解析后：变量提升 var num; console.log(num); // 所以返回的是一个undefined num = 666; 函数预解析 将所有函数声明提升到当前作用域的最前面。 下面是预解析前编写的代码。 // 原始代码 f1(); // 能够正常调用 function f1() { console.log('Albert唱歌太好听了'); } 预解析后，函数声明提升到最前面。 function f1() { console.log('Albert唱歌太好听了'); } f1(); //预解析后，代码是逐行执行的，执行到 f1()后，去调用函数 f1（） 闭包 官方说法：JS 的闭包是指一个函数与周围状态（词法环境）的引用捆绑在一起（封闭）的组合，在 JS 中，每次创建函数时，都会同时创建闭包。闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰，即形成一个不销毁的栈环境。 通俗的将，就是父函数中包含一个子函数，子函数可以调用父函数中的变量。 闭包示例 1 function parent() { let x = 0; function children() { return ++x; } return children; // 返回children函数 } let children = parent(); // 创建children函数 console.log(children()); // 1 console.log(children()); // 2 console.log(children()); // 3 console.log(children()); // 4 // 创建新的children函数 children = parent(); console.log(children()); // 1 闭包示例 2 // 普通的函数 function f1() { let num = 0; num++; return num; } // 每次执行f1, num都是重新定义，并且初始化为0 console.log(f1()); // 1 console.log(f1()); // 1 console.log(f1()); // 1 // 闭包 function f2() { let num = 0; return function () { num++; return num; }; } var ff = f2(); // ff = function() { num++; return num; } // num 本来在 f2的作用域中，但是 ff 也可以调用，破坏了 num 的作用域。 console.log(ff()); // 1 console.log(ff()); // 2 console.log(ff()); // 3 闭包的作用 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。 在一些编程语言中，比如 Java，是支持将方法声明为私有的(private)，即它们只能被同一个类中的其它方法所调用。而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。 私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面我们计数器为例，代码如下。 // 闭包的作用 var myCounter = function () { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function () { changeBy(1); }, decrement: function () { changeBy(-1); }, value: function () { return privateCounter; }, }; }; var Counter1 = myCounter(); var Counter2 = myCounter(); console.log(Counter1.value()); /* 计数器1现在为 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* 计数器1现在为 2 */ Counter1.decrement(); console.log(Counter1.value()); /* 计数器1现在为 1 */ console.log(Counter2.value()); /* 计数器2现在为 0 */ Counter2.increment(); console.log(Counter2.value()); /* 计数器2现在为 1 */ 在上边的代码中我们创建了一个匿名函数含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问，Counter.increment，Counter.decrement 和 Counter.value，这三个公共函数共享同一个环境的闭包，多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。我们把匿名函数储存在一个变量 myCounter 中，并用它来创建多个计数器，每次创建都会同时创建闭包，因为每个闭包都有它自己的词法环境，每个闭包都是引用自己词法作用域内的变量 privateCounter ，所以两个计数器 Counter1 和 Counter2 是各自独立的。以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。 闭包的危害 通常来说，函数的活动对象会随着执行期上下文一起销毁，但是，由于闭包引用另外一个函数的活动对象，因此这个活动对象无法被销毁，这意味着，闭包比一般的函数需要更多的内存消耗。 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。 因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。 执行上下文 在 JavaScript 中，执行上下文是一个基本的概念，但其中又包含了变量对象、作用域链、this 指向等更深入的内容，深入理解执行上下文以及其中的内容，对我们以后理解 JavaScript 中其它更深入的知识点（函数/变量提升、闭包等）会有很大的帮助。 执行上下文可以理解为当前代码的运行环境。在 JavaScript 中，运行环境主要包含了全局环境和函数环境。 在 JavaScript 代码运行过程中，最先进入的是全局环境，而在函数被调用时则进入相应的函数环境。全局环境和函数环境所对应的执行上下文我们分别称为全局上下文和函数上下文。 执行上下文栈 在一个 JavaScript 文件中，经常会有多个函数被调用，也就是说在 JavaScript 代码运行过程中很可能会产生多个执行上下文，那么如何去管理这多个执行上下文呢？ 执行上下文是以栈（一种 LIFO 的数据结构）的方式被存放起来的，我们称之为执行上下文栈（Execution Context Stack）。 在 JavaScript 代码开始执行时，首先进入全局环境，此时全局上下文被创建并入栈，之后当调用函数时则进入相应的函数环境，此时相应函数上下文被创建并入栈，当处于栈顶的执行上下文代码执行完毕后，则会将其出栈。 所以在执行上下文栈中，栈底永远是全局上下文，而栈顶则是当前正在执行的函数上下文。 文字表达既枯燥又难以理解，让我们来看一个简单的例子吧。 function fn2() { console.log('fn2') } function fn1() { console.log('fn1') fn2(); } fn1(); 运行上述代码，可以得到相应的输出，那么上述代码在执行过程中执行上下文栈的行为是怎样的呢？ /* 伪代码 以数组来表示执行上下文栈 ECStack=[] */ // 代码执行时最先进入全局环境，全局上下文被创建并入栈 ECStack.push(global_EC); // fn1 被调用，fn1 函数上下文被创建并入栈 ECStack.push(fn1_EC); // fn1 中调用 fn2，fn2 函数上下文被创建并入栈 ECStack.push(fn2_EC); // fn2 执行完毕，fn2 函数上下文出栈 ECStack.pop(); // fn1 执行完毕，fn1 函数上下文出栈 ECStack.pop(); // 代码执行完毕，全局上下文出栈 ECStack.pop(); 执行的顺序可以用下面的图来表示。 上下文生命周期 在一个执行上下文中，最重要的三个属性分别是变量对象（Variable Object）、作用域链（Scope Chain）和 this 指向。 一个执行上下文的生命周期分为创建和执行阶段。创建阶段主要工作是生成变量对象、建立作用域链和确定 this 指向。而执行阶段主要工作是变量赋值以及执行其它代码等。 下面，我们就来看看创建阶段和执行阶段的不同。 创建阶段：检索当前上下文的传入参数、变量声明和函数声明。 执行阶段：赋值、执行其他代码。 [!note] 创建上下文过程，只声明变量和函数，不对其进行赋值，只有在执行的时候才进行赋值。这就是我们之前说过的变量提升和函数提升的内在机制。 上下文 & 作用域链 了解了上下文知识，我们再来回顾一下作用域链。 作用域链是指由当前上下文和上层上下文的一系列变量对象组成的层级链。它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 我们已经知道，上下文分为创建和执行两个阶段，在执行阶段，如果需要使用某个变量，首先在当前上下文查找， 如果找不到则去下一层上下文查找，直至最底层全局上下文查找。 上下文 & this 指向 了解了上下文知识，我们再来看看上下文与 this 指向之间的关系。 this 的指向，是在函数被调用的时候确定的，也就是上下文被创建时确定的。 关于 this 的指向，其实最主要的是三种场景，分别是全局上下文中 this、函数中 this 和构造函数中 this。 我们再来总结一下： 全局上下文中的 this，指向全局对象 window。 函数中的 this，严格模式下是 undefined，非严格模式下是 window。 构造函数中的 this，指向实例对象。 上下文 & 闭包 在各个上下文出栈后，其对应的变量对象会被 JavaScript 中的自动垃圾收集机制回收。 而我们经常说闭包能够访问其所在环境的变量，其实是因为闭包能够阻止上述变量对象被回收的过程。 异步编程 JS 是单线程的，在浏览器中 js 的执行栈跟渲染线程是相互阻塞的。 单线程模式最大的优势就是更安全，更简单 缺点也很明确，就是如果中间有一个特别耗时的任务，其他的任务就要等待很长的时间，出现假死的情况。 为了解决这种问题，JS 有两种任务的执行模式：同步模式（Synchronous）和异步模式（Asynchronous）。 同步和异步 同步模式 Synchronous程序的执行顺序和代码的编写顺序是完全一致的。代码按顺序执行，后一个任务必须等前一个任务执行完才能执行。 一旦有任务卡住或执行较慢，则后续所有代码都会受到影响。 异步模式 Asynchronous 不会去等待这个任务的结束才开始下一个任务，都是开启过后就立即往后执行下一个任务。 耗时函数的后续逻辑会通过回调函数的方式定义，任务完成后，就会调用回调函数。 回调函数异步方案 回调函数由调用者定义，交给执行者执行的函数 // callback就是回调函数 // 就是把函数作为参数传递，缺点是不利于阅读，执行顺序混乱。 function foo(callback) { setTimeout(function () { callback(); }, 3000); } foo(function () { console.log('这就是一个回调函数'); console.log('调用者定义这个函数，执行者执行这个函数'); console.log('其实就是调用者告诉执行者异步任务结束后应该做什么'); }); Promise 异步方案 回调的多重嵌套，会导致代码可读低、编写费劲、容易出错，故而被称为 callback hell（回调地狱）。 为了避免这个问题。CommonJS 社区提出了 Promise 的规范，ES6 中称为语言规范。 [!note] Promise 并不算是真正的异步，只不过是回调函数的语法糖形式。 回调函数是横向拓展，而 Promise 将其转换成了竖向拓展。 Promise 是一个对象，用来表述一个异步任务执行之后是成功还是失败，它有多个状态： Pending 待定状态, 表示还不清楚异步执行的结果 是成功还是失败。 Fulfilled 完成状态, 表示操作已经完成 Rejected 操作失败 Promise 基本用法 const promise = new Promise((resolve, reject) => { if (true) resolve(100); else reject(new Error('promise rejected')); }); promise.then( (value) => { console.log('resolved', value); // 100 }, (error) => { console.log('rejected', error); // rejected Error: promise rejected } ); Promise 链式调用 promise 对象 then 方法，返回了全新的 promise 对象。可以再继续调用 then 方法，如果 return 的不是 promise 对象，而是一个值，那么这个值会作为 resolve 的值传递，如果没有值，默认是 undefined。 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调。 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数。 如果回调中返回的是 Promise，那后面 then 方法的回调会等待它的结束。 // promise假设是一个Promise实例 // then中的回调return了一个Promise实例 promise .then(() => { return new Promise((resolve, reject) => { // some code resolve('实参A'); }); }) .then((接收实参A) => { // 作为上一个then中的回调; }); // then中回调return的不是promise实例 promise .then(() => { return 123; }) .then((val) => { console.log(val); // 123 }); Promise 异常处理 catch 函数来捕获异常。 如果 then 中没有传入第二个回调 那么异常会进入 catch 的回调处理。 promise 中如果有异常，都会调用 reject 方法，还可以使用.catch()。 使用.catch 方法更为常见，因为更加符合链式调用。 const promise = new Promise((resolve, rejcet) => { rejcet(new Error('Some Error.')); }); promise .then(() => { console.log('success'); }) .catch((error) => { console.log(error); // Error: Some Error. }); Promise 并行执行 Promise.all()：全部执行结束则返回。 const p1 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('1秒'); // 1秒后输出 resolve(1); }, 1000); }); const p2 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('2秒'); // 2秒后输出 resolve(2); }, 2000); }); const p3 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('3秒'); // 3秒后输出 resolve(3); }, 3000); }); Promise.all([p1, p2, p3]).then((values) => { console.log(values); // [1, 2, 3] }); Promise.race()：先结束的就直接返回。 const p1 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('1秒'); // 1秒后输出 resolve(1); }, 1000); }); const p2 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('2秒'); // 2秒后输出 resolve(2); }, 2000); }); const p3 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('3秒'); // 3秒后输出 resolve(3); }, 3000); }); Promise.race([p1, p2, p3]).then((values) => { console.log(values); // p1执行结束后就输出 1 }); Generator 异步方案 Generator 函数 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 // Generator 函数定义 function* gen(x) { let y = yield x + 2; yield 5; return y; } // Generator 函数执行 let g = gen(1); // 内部指针（遍历器）g let res1 = g.next(); // 调用g的next，内部执行知道遇到yield语句 let res2 = g.next(); let res3 = g.next(); let res4 = g.next(); console.log('res1', res1); console.log('res2', res2); console.log('res3', res3); console.log('res4', res3); /** output res1 { value: 3, done: false } res2 { value: 5, done: false } res3 { value: undefined, done: true } res4 { value: undefined, done: true } */ 上面的函数就是一个 Generator 函数，他不同于普通函数，他是可以暂停的，所以 function 后面加*号，以示区别。 每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 整个 Generator 函数都是一个异步的容器，容器中需要暂停的地方都是用yield来注明。 数据交换和错误处理 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 数据交换 next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。 function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); console.log(g.next()); console.log(g.next(6)); /** output { value: 3, done: false } { value: 6, done: true } */ 上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数 2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是 6（变量 y 的值）。 错误处理 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 function* gen(x) { try { var y = yield x + 2; } catch (e) { console.log(e); } return y; } var g = gen(1); console.log(g.next()); console.log(g.throw('抛出错误！')); /** output { value: 3, done: false } 抛出错误！ { value: undefined, done: true } */ 上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try ... catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 async/await 异步方案 async/await 是 Generator 函数的语法糖形式。 async作为一个关键字放在函数的前面，表示该函数是一个异步函数，意味着该函数的执行不会阻塞后面代码的执行 异步函数的调用跟普通函数一样。 await就是 yeild 的功能，async 函数中的暂停。 async 函数返回的结果是一个 Promise 对象，要获取 Promise 的返回值应该用 then 方法。 async function timeout() { return 'hello world'; } timeout().then((result) => { console.log(result); }); console.log('我在异步函数后面，会先执行谁呢？'); /** output 我在异步函数后面，会先执行谁呢？ hello world */ 此时先输出的就是后面的一串文字，说明异步函数的执行没有阻塞后面的代码执行，async的内部实现原理就是如果该函数中有一个返回值，当调用该函数时，默认会在内部调用Promise.solve() 方法把它转化成一个Promise 对象作为返回，若函数内部抛出错误，则调用Promise.reject()返回一个Promise 对象。 正则表达式 正则表达式在各种编程语言中，都有广泛的应用。在 JavaScript 中更是不可或缺，正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文。 此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 本文从正则表达式的基本概念入手，讲解了正则表达式的特点和组成，并且详细讲解了正则表达式在 JavaScript 中的使用，并给出了一些在实际开发中经常用到的实例。 什么是正则表达式 正则表达式是用于匹配规律规则的表达式，它的“鼻祖”可一直追溯到科学家对人类神经系统的工作原理的早期研究。现在在各种编程语言中，正则表达式都有广泛的应用。在 JavaScript 中，正则表达式也是对象，正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配)。 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)。 强大的字符串替换能力(替换)。 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \\d 匹配数字 ab\\d 匹配 ab1、ab2 元字符串 常用元字符串 元字符 说明 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复 n 次 {n,} 重复 n 次或更多次 {n,m} 重复 n 到 m 次 其它符号 符号 说明 [] 字符串用中括号括起来，表示匹配其中的任一字符。 [^] 匹配中括号以外的内容，相当于”非“的意思 \\ 转义符 〡 选择两者中的一个，相当于”或者“ () 从两个直接量中选择一个，分组。 例如：gr(a 〡 e)y 匹配 gray 和 grey。 [\\u4e00-\\u9fa5] 匹配汉字 常用的正则表达式 // 验证手机号是否11位 /^\\d{11}$/ /^1[3-9]\\d{9}$/ // 验证邮编 /^\\d{6}$/ // 验证日期 yyyy-mm-dd /^\\d{4}-\\d{1,2}-\\d{1,2}$/ // 验证邮箱 /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_-]+([.][a-zA-Z]+){1,2}$/ // 验证IP地址 xxx.xxx.xxx.xxx /^\\d{1,3}\\(.\\d{1,3}){3}$/ // 验证中文 /^[\\u4e00-\\u9fa5]{2,6}$/ // 验证身份证 /^[1-9]\\d{5}(18|19|20|(3\\d))\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/ "},"Chapter2/":{"url":"Chapter2/","title":"第二章 Node.js 技术","keywords":"","body":" Node.js技术 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个事件驱动 I/O服务端 JavaScript 环境，基于 Google 的Chrome V8 引擎，V8 引擎执行 JavaScript 的速度非常快，性能非常好。 JavaScript 是一个单线程的语言，单线程的优点是不会像 Java 这些多线程语言在编程时出现线程同步、线程锁问题同时也避免了上下文切换带来的性能开销问题。那么其实在浏览器环境也只能是单线程，可以想象一下多线程对同一个 DOM 进行操作是什么场景？不是乱套了吗？ 那么单线程可能你会想到的一个问题是，前面一个执行不完，后面不就卡住了吗？当然不能这样子的，JavaScript 是一种采用了事件驱动、异步回调的模式。另外 JavaScript 在服务端不存在什么历史包袱，在虚拟机上由于又有了 Chrome V8 的支持，使得 JavaScript 成为了 Node.js 的首选语言。 "},"Chapter2/1.html":{"url":"Chapter2/1.html","title":"一、Node.js 基础","keywords":"","body":"Node.js 基础 简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个事件驱动 I/O服务端 JavaScript 环境，基于 Google 的Chrome V8 引擎，V8 引擎执行 JavaScript 的速度非常快，性能非常好。 Node.js 概念 架构 Node.js 由 Libuv、Chrome V8、一些核心 API 构成。其标准架构如下图所示。 上面展示了 Node.js 的架构，下面做简单说明。 Node Standard Library Node.js 标准库，对外提供的 JavaScript 接口，例如模块 http、buffer、fs、stream 等 Node bindings 这里就是 JavaScript 与 C++ 连接的桥梁，对下层模块进行封装，向上层提供基础的 API 接口。 V8 Engine Google 开源的高性能 JavaScript 引擎，使用 C++ 开发，并且应用于谷歌浏览器。 Libuv 是一个跨平台的支持事件驱动的 I/O 库。它是使用 C 和 C++ 语言为 Node.js 所开发的，同时也是 I/O 操作的核心部分，例如读取文件和 OS 交互。 C-ares C-ares 是一个异步 DNS 解析库 Low-Level Components 提供了 http 解析、OpenSSL、数据压缩（zlib）等功能。 运行原理 我们先从代码的运行角度来看 Node.js 的架构，代码运行的示例图如下所示。 上图主要分为三块，最底层就是我们的主机环境（macOS、windows、Linux），上面就是我们的 Node.js 运行环境，最顶层就是我们编写的代码。这里，我们重点介绍中间的 Node.js 部分。 V8 engine Chrome V8 引擎。主要提供两个功能： 虚拟机动能，执行 JS 代码（自己的代码、第三方代码和内置代码等）。 提供 C++函数接口，为 Node.js 提供 V8 初始化，创建 context，scope 等。 Libuv 它是基于事件驱动的异步 IO 模型库，我们的 JS 代码发出请求，最终由 Libuv 完成，而我们所设置的回调函数则是在 Libuv 触发。 Buildin modules 它是由 C++代码写成各类模块，包含了 crypto，zlib, file stream etc 基础功能。（v8 提供了函数接口，libuv 提供异步 IO 模型库，以及一些 nodejs 函数，为 builtin modules 提供服务）。 Native modules 它是由 JS 写成，提供我们应用程序调用的库，同时这些模块又依赖 builtin modules 来获取相应的服务支持。 [!note] 如果把 Nodejs 看做一个黑匣子，起暴露给开发者的接口则是 Native modules 原生模块，当我们发起请求时，请求自上而下，穿越 Native modules，在 V8 引擎上执行。V8 引擎通过调用 Builtin modules 内置模块提供的接口，将请求传送至 Libuv 和其他辅助服务，由 Libuv 执行。执行结束后，则从下回溯至上，最终调用我们的回调函数。 当我们执行node xxx.js的时候，Node.js 会先做一些 V8 初试化，Libuv 启动的工作，然后交由 V8 来执行 Native modules 以及我们的 JS 代码。 特点 Node.js 采用事件驱动和异步 I/O 的方式，实现了一个单线程、高并发的 JavaScript 运行时环境。 单线程就意味着同一时间只能做一件事，那么 Node.js 如何通过单线程来实现高并发和异步 I/O 呢？首先，我们来看下 Node.js 的主要特点： 一个单线程、高并发的 Javascript 运行环境 依赖于 Chrome V8 引擎进行代码解释 事件驱动 异步 I/O（也称作“非阻塞 IO”。注：Linux 的异步 IO 和非阻塞 IO 不是同一类。） 轻量、可伸缩，适于实时数据交互应用 单进程，单线程 上述特点中，最主要的两个就是事件驱动和异步 IO。 异步 IO 异步 IO 是 Node.js 处理高并发请求的策略。一般来说，高并发的解决方案就是提供多线程模型，服务器为每个客户端请求分配一个线程，使用同步 I/O，系统通过线程切换来弥补同步 I/O 调用的时间开销。比如 Apache 就是这种策略，由于 I/O 一般都是耗时操作，因此这种策略很难实现高性能，但非常简单，可以实现复杂的交互逻辑。 而事实上，大多数网站的服务器端都不会做太多的计算，它们接收到请求以后，把请求交给其它服务来处理（比如读取数据库），然后等着结果返回，最后再把结果发给客户端。因此，Node.js 针对这一事实采用了单线程模型来处理，它不会为每个接入请求分配一个线程，而是用一个主线程处理所有的请求，然后对 I/O 操作进行异步处理，避开了创建、销毁线程以及在线程间切换所需的开销和复杂性。 事件驱动 Node.js 在主线程里维护了一个事件队列，当接到请求后，就将该请求作为一个事件放入这个队列中，然后继续接收其他请求。当主线程空闲时(没有请求接入时)，就开始循环事件队列，检查队列中是否有要处理的事件，这时要分两种情况：如果是非 I/O 任务，就亲自处理，并通过回调函数返回到上层调用；如果是 I/O 任务，就从 线程池 中拿出一个线程来处理这个事件，并指定回调函数，然后继续循环队列中的其他事件。 当线程中的 I/O 任务完成以后，就执行指定的回调函数，并把这个完成的事件放到事件队列的尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用。 这个过程就叫 事件循环 (Event Loop)，其运行原理如下图所示。 这个图是整个 Node.js 的运行原理，从左到右，从上到下，Node.js 被分为了四层，分别是 应用层、V8 引擎层、Node API 层 和 Libuv 层。 [!note] 应用层： 即 JavaScript 交互层，常见的就是 Node.js 的模块，比如原生模块 http，fs 等。 V8 引擎层： 即利用 V8 引擎来解析 JavaScript 语法，进而和下层 API 交互。 NodeAPI 层： 内置模块，一般是由 C/C++ 语言来实现，为上层模块提供系统调用，和操作系统进行交互 。 Libuv 层： 是跨平台的底层封装，实现了事件循环、文件操作等，是 Node.js 实现异步的核心 。 无论是 Linux 平台还是 Windows 平台，Node.js 内部都是通过线程池来完成异步 I/O 操作的，而 Libuv 针对不同平台的差异性实现了统一调用。因此，Node.js 的单线程仅仅是指 JavaScript 运行在单线程中，而并非 Node.js 是单线程。我们可以简单的理解为，Node.js 本身是一个多线程平台，而它对 JavaScript 层面的任务处理是单线程的。 解决的问题 并发连接 异步 IO、事件驱动整个过程没有阻塞新用户的连接，也不需要维护已有用户的连接。 基于这样的机制，理论上陆续有用户请求连接，Node.js 都可以进行响应，因此 Node.js 能支持比 Java、PHP 程序更高的并发量。 但是，维护事件队列也需要成本，再由于 Node.js 是单线程，事件队列越长，得到响应的时间就越长，并发量上去还是会力不从心。 IO 阻塞 IO 密集型处理是 Node.js 的强项，虽然 Java、PHP 也有办法实现并行请求（子线程），但 Node.js 通过回调函数（callback）和异步机制会做得很自然。 优缺点 优点 高并发（最重要的优点） 适合 I/O 密集型应用 缺点 不适合 CPU 密集型应用，如加解密数据、解/压缩文件等。 只支持单核 CPU，不能充分利用 CPU（单线程、单进程）。 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃（单线程、单进程）。 适合的场景 RESTful API 这是 Node.js 最理想的应用场景，可以处理数万条连接，本身没有太多的逻辑，只需要请求 API，组织数据进行返回即可。 它本质上只是从某个数据库中查找一些值并将它们组成一个响应。由于响应是少量文本，入站请求也是少量的文本，因此流量不高，一台机器甚至也可以处理最繁忙的公司的 API 需求。 统一 Web 应用的 UI 层 目前 MVC 的架构，在某种意义上来说，Web 开发有两个 UI 层，一个是在浏览器里面我们最终看到的，另一个在 server 端，负责生成和拼接页面。 不讨论这种架构是好是坏，但是有另外一种实践，面向服务的架构，更好的做前后端的依赖分离。如果所有的关键业务逻辑都封装成 REST 调用，就意味着在上层只需要考虑如何用这些 REST 接口构建具体的应用。那些后端程序员们根本不操心具体数据是如何从一个页面传递到另一个页面的，他们也不用管用户数据更新是通过 Ajax 异步获取的还是通过刷新页面。 大量 Ajax 请求的应用 例如个性化应用，每个用户看到的页面都不一样，缓存失效，需要在页面加载的时候发起 Ajax 请求，Node.js 能响应大量的并发请求。 总而言之，Node.js 适合运用在高并发、I/O 密集、少量业务逻辑的场景。 模块机制 Node.js 模块机制采用了 CommonJS 规范，弥补了当前 JavaScript 开发大型应用没有标准的缺陷，类似于 Java 中的类文件，Python 中的 import 机制，Node.js 中可以通过 module.exports、require 来导出和引入一个模块 在模块加载机制中，Node.js 采用了延迟加载的策略，只有在用到的情况下，系统模块才会被加载，加载完成后会放到binding_cache缓存中。 模块分类 系统模块 内建模块：Buildin modules，也叫 C/C++模块。一般用于原生模块调用。 原生模块：Native modules，是 Node.js 的核心模块。这些模块定义在 Node.js 源代码的 lib/ 目录下。在开发中使用的 Node.js 的 http、buffer、fs 等都是 Node.js 的原生模块，其底层也是调用的内建模块 (C/C++)。 第三方模块 非 Node.js 自带的模块称为第三方模块，其实还分为路径形式的文件模块（以 .、..、/ 开头的）和自定义的模块（比如 express、koa 框架、moment.js 等） JavaScript 模块：例如 hello.js。 JSON 模块：例如 hello.json。 C/C++ 模块：编译之后扩展名为 .node 的模块，例如 hello.node。 模块的引入和导出 Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 require 引入模块 在 Node.js 中，引入一个模块非常简单，如下我们创建一个 main.js 文件并引入 hello 模块，代码如下: var hello = require('./hello'); hello.world(); 以上实例中，代码 require('./hello') 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。 [!note] 并不常见的 module.require()方法 对于模块的引用，常见的写法是 require()，但是看过 Node.js 官方文档的同学可能知道，Node.js 的 module 对象有很多属性和方法，比如： module.filename：模块完全解析后的文件名 module.path：模块的路径 module.paths：模块的搜索路径 module.require：模块的引用（不常见） 现在有这样几个文件： ├── a │ ├── index.js │ └── name.js └── b ├── index.js └── name.js // a/name.js module.exports = 'AAA'; // a/index.js const aname = require('./name'); // 引用的是'a/name.js' const bModule = require('../b'); const bName = bModule.require('./name'); // 引用的是'b/name.js' console.log(aname); // 输出：AAA console.log(bName); // 输出：BBB // b/name.js module.exports = 'BBB'; // b/index.js module.exports = module; 然后，我们执行node a/index.js，可以看出虽然都是引用的'./name.js'模块，但是引用的是不同的模块，所以输出不同。 exports 导出模块 程序的导出通过 module.exports 实现，module.exports 可以对外提供函数、变量或者对象。 在每个模块中， module 的自由变量是对表示当前模块的对象的引用。 为方便起见，还可以通过全局模块的 exports 访问 module.exports。 module 实际上不是全局的，而是每个模块本地的。 接下来我们就来创建 hello.js 文件，代码如下： // 直接导出 world 函数 exports.world = function () { console.log('Hello World'); }; 在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require('./hello') 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。 有时候我们只是想把一个对象封装到模块中，例如： //hello.js function Hello() { var name; this.setName = function (thyName) { name = thyName; }; this.sayHello = function () { console.log('Hello ' + name); }; } module.exports = Hello; 这样就可以直接获得这个对象了： //main.js var Hello = require('./hello'); hello = new Hello(); hello.setName('Lou'); hello.sayHello(); 模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。即当一个模块既有 exports，又有 module.exports 时，模块的导出是 module.exports，而 exports 会被忽略。 [!note] exports 和 module.exports 的区别？ exports 相当于 module.exports 的快捷方式，原理如下所示。 // Node.js 内核原理 var module = { exports: {}, // module对象中有一个exports引用类型 }; exports = module.exports; // 将 module.exports 指向 exports 我们可以对 exports 中的属性进行赋值，比如这样是正常的写法： // ✅ 正确的写法 exports.name = 'A'; exports.add = function () { console.log('hi'); }; 但是，我们不能对 exports 重新赋值，这样仍然不会改变 module.exports 的内容。 // ❌ 错误的写法 // exports被重新赋值，就不再和 module.exports 一样了 exports = { name: 'A', add: function () { console.log('hi'); }, }; 所以，为了保险起见，我们一般建议使用 module.exports 的写法： // ✅ 非常非常非常正确的写法！！！ module.exports = { name: 'A', add: function () { console.log('hi'); }, }; 模块加载 也许你已经注意到，我们已经在代码中使用了模块了。像这样： var httpObj = require(\"http\"); // some code httpObj.createServer(...); Node.js 中自带了一个叫做 http 的模块，我们在我们的代码中请求它并把返回值赋给一个本地变量。 这把我们的本地变量变成了一个拥有所有 http 模块所提供的公共方法的对象。 Node.js 的 require 方法中的文件查找策略如下： 由于 Node.js 中存在各种类型的模块（内置模块、JS 模块、JSON 模块、C/C++模块等），尽管 require 方法极其简单，但是内部的加载却是十分复杂的，其加载优先级也各自不同。如下图所示： 在 Node.js 中模块加载一般会经历 3 个步骤，路径分析、文件定位、编译执行。 当然，加载的优先级不同。 系统缓存加载：模块被执行之后会会进行缓存，首先是先进行缓存加载，判断缓存中是否有值。 原生模块加载：也就是系统模块，这个优先级仅次于缓存加载，部分核心模块已经被编译成二进制，省略了路径分析和文件定位，直接加载到了内存中，系统模块定义在 Node.js 源码的 lib 目录下，可以去查看。 文件模块加载：优先加载.、..、/等开头的相对路径，如果文件没有加拓展名，会依次按照.js、.json、.node依次补足尝试，那么在尝试的过程中也是以同步阻塞模式来判断文件是否存在，从性能优化的角度来看待，.json、.node最好还是加上文件的扩展名。 目录作为模块加载：这种情况发生在文件模块加载过程中，也没有找到，但是发现是一个目录的情况，这个时候会将这个目录当作一个包来处理，Node 这块采用了 CommonJS 规范，先会在项目根目录查找 package.json 文件，取出文件中定义的 main 属性 (\"main\": \"lib/hello.js\") 描述的入口文件进行加载，也没加载到，则会抛出默认错误Error: Cannot find module 'lib/hello.js'。 node_modules 目录加载：对于系统模块、路径文件模块都找不到，Node.JS 会从当前模块的父目录进行查找，直到系统的根目录。 模块缓存 模块在第一次加载后会被缓存，多次 require 调用模块不会导致模块的代码被执行多次。，这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。 模块加载后会被缓存起来，那么缓存在哪里呢？ Node.js 提供了 require.cache API 查看已缓存的模块，返回值为对象，为了验证，这里做一个简单的测试。 新建一个test-modules.js文件，作为模块文件，文件内容如下： module.exports = { a: 1, test: () => {}, }; 新建一个执行文件test.js，文件内容如下： require('./test-module.js'); console.log(require.cache); 执行命令node test.js，控制台输出信息如下： ➜ code git:(master) ✗ node test.js [Object: null prototype] { '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test.js': Module { id: '.', exports: {}, parent: null, filename: '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test.js', loaded: false, children: [ [Module] ], paths: [ '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/node_modules', '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/node_modules', '/Users/pg/Documents/Gitee/nodejs-blue-book/node_modules', '/Users/pg/Documents/Gitee/node_modules', '/Users/pg/Documents/node_modules', '/Users/pg/node_modules', '/Users/node_modules', '/node_modules' ] }, '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test-module.js': Module { id: '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test-module.js', exports: { a: 1, test: [Function: test] }, parent: Module { id: '.', exports: {}, parent: null, filename: '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test.js', loaded: false, children: [Array], paths: [Array] }, filename: '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/test-module.js', loaded: true, children: [], paths: [ '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/code/node_modules', '/Users/pg/Documents/Gitee/nodejs-blue-book/Chapter2/node_modules', '/Users/pg/Documents/Gitee/nodejs-blue-book/node_modules', '/Users/pg/Documents/Gitee/node_modules', '/Users/pg/Documents/node_modules', '/Users/pg/node_modules', '/Users/node_modules', '/node_modules' ] } } 从上面的输出我们可以看到，模块的文件名、地址和导出数据都输出了。 [!note] 被引入的模块将被缓存在这个对象中。 从此对象中删除键值对将会导致下一次require重新加载被删除的模块。 这不适用于原生模块，因为它们的重载将会导致错误。 可以添加或替换入口。 在加载原生模块之前会检查此缓存，如果将与原生模块匹配的名称添加到缓存中，则引入调用将不再获取原生模块。 谨慎使用！ 模块循环引用 首先，我们通过代码演示一下 require 的运行逻辑。 function require(/* ... */) { const module = { exports: {} }; // 模块的导出是默认的{} ((module, exports) => { // 模块代码在这。在这个例子中，定义了一个函数。 function someFunc() {} exports = someFunc; // 此时，exports 不再是一个 module.exports 的快捷方式 /*** 截止到上面，该模块导出仍然是默认对象{} ***/ module.exports = someFunc; // 此时，该模块导出才是 someFunc，而不是默认对象。 })(module, module.exports); return module.exports; } 现在，我们思考这样一种场景。假设现在有 a.js、b.js 两个文件，两个文件模块相互引用，如下所示： // a.js console.log('a模块start'); exports.test = 1; undeclaredVariable = 'a模块未声明变量'; const b = require('./b'); console.log('a模块加载完毕: b.test值：', b.test); // b.js console.log('b模块start'); exports.test = 2; const a = require('./a'); console.log('undeclaredVariable: ', undeclaredVariable); console.log('b模块加载完毕: a.test值：', a.test); 如果执行node a.js，结果会怎样？思考两个问题： a 和 b 相互引用，是否会陷入死循环？ b 中undeclaredVariable能否获取到值？ 经过实验，我们执行的结果如下： a模块start b模块start undeclaredVariable: a模块未声明变量 b模块加载完毕: a.test值： 1 a模块加载完毕: b.test值： 2 启动 a.js 的时候，会加载 b.js，那么在 b.js 中又加载了 a.js，但是此时 a.js 模块还没有执行完，返回的是一个 a.js 模块的 exports 对象未完成的副本给到 b.js 模块（因此是不会陷入死循环的）。然后 b.js 完成加载之后将 exports 对象提供给了 a.js 模块。 又因为 undeclaredVariable 是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方当然是可以拿到的。 在执行代码之前，Node.js 会使用一个代码封装器进行封装，例如下面所示： (function (exports, require, module, __filename, __dirname) { // 模块的代码 }); 事件 Node.js 两大特性分别是事件驱动和异步 IO，我们先来看看 Node.js 的事件。 Event Loop 事件驱动和异步 IO的核心都是通过 Event Loop 来实现的，上一篇我们简单介绍了 Event Loop 的运行原理，本篇我们将具体来介绍一下 Event Loop 的相关知识。 Event Loop 是一个执行模型，在不同的地方有不同的实现。浏览器和 Node.js 基于不同的技术实现了各自的 Event Loop。 [!note] 浏览器的 Event Loop 是在HTML5 的规范中明确定义。 Node.js 的 Event Loop 是基于 Libuv 实现的（上一篇介绍过）。 Libuv 已经对 Event Loop 做出了实现，而 HTML5 规范中只是定义了浏览器中 Event Loop 的模型，具体的实现留给了浏览器厂商。 宏队列和微队列 名称 定义 异步任务 宏队列 macrotask，也叫 tasks。异步任务的回调会依次进入宏队列。 setTimeoutsetIntervalsetImmediate (Node 独有) requestAnimationFrame (浏览器独有)UI rendering (浏览器独有)I/O 微队列 microtask，也叫 jobs。异步任务的回调会依次进入微队列。 process.nextTick (Node 独有) Promise Object.observe MutationObserver 浏览器事件循环 执行过程 我们先来看一张图（一定要仔细看，对后续学习有帮助）。 这张图将浏览器的 Event Loop 完整的描述了出来，我来讲执行一个 JavaScript 代码的具体流程。 初始状态，执行栈和微队列都是空，宏队列只有一个全局 Script 代码准备执行。 执行全局 Script 同步代码。这些同步代码有一些是同步语句，有一些是异步语句（比如 setTimeout 等）； 全局 Script 代码执行完毕后，调用栈 Stack 会清空。 执行微队列。从微队列中取出位于队首的回调任务，放入执行栈 Stack 中执行，执行完后微队列的长度减 1。 继续取出微队列位于队首的任务，放入调用栈 Stack 中执行，以此类推，直到直到把微队列中的所有任务都执行完毕。 注意，如果在执行微队列的过程中，又产生了微队列，那么会加入到队列的末尾，也会在这个周期被调用执行。 微队列中的所有任务都执行完毕，此时微队列为空队列，执行栈 Stack 也为空。 执行宏队列。取出宏队列 macrotask queue 中位于队首的任务，放入 Stack 中执行。 所有宏队列都执行完毕后，执行栈 Stack 为空。 浏览器执行渲染操作，更新界面（如果有就执行，浏览器自行判断）。 检查是否存在 Web worker 任务，如果有，则对其进行处理 。 上述过程循环往复，直到两个队列都清空。 [!note] 宏队列是一个一个的执行。微队列是一队一队的执行。 宏队列执行完，就执行微队列中的任务。 执行微队列过程中，只要微队列中有 jobs（无论是执行前插入的还是执行过程中插入的），就会一直按顺序执行。 第 9 步浏览器渲染没有在图中画出来，因为这个是由浏览器自行判断决定的。渲染操作在微队列结束后，宏队列开始前执行。如果你需要在异步的操作后重新渲染 DOM 最好的方法是将它包装成 micro 任务，这样 DOM 渲染将会在本次 Tick 内就完成。 练习 我们来看一看，下面的代码输出的是什么？ // console1 console.log(1); // setTimeout1 setTimeout(() => { // callback1 // console3 console.log(2); // Promise2 Promise.resolve().then(() => { // callback4 console.log(3); }); }); // Promise1 new Promise((resolve, reject) => { console.log(4); resolve(5); }).then((data) => { // callbace2 console.log(data); }); // setTimeout2 setTimeout(() => { // callback3 console.log(6); }); // console2 console.log(7); 我们来分析一下程序执行的流程。 步骤 执行栈 微队列 宏队列 输出 执行全局 JS 代码 全局代码 执行宏队列第一行console1。console1是同步任务，直接执行。 console1 全局代码 1 执行setTimeout1，其回调任务callback1放到宏队列。 setTimeout1 全局代码callback1 1 执行Promise1，其回调任务callbace2放到微队列。 Promise1 callback2 全局代码callback1 14 执行setTimeout2，其回调任务callback3放到宏队列。 setTimeout2 callback2 全局代码callback1 cakkback3 14 执行最后一行console2。console2是同步任务，直接执行。 console2 callback2 全局代码callback1 cakkback3 147 全局 Script 代码都执行完毕 callback2 callback1 cakkback3 147 先执行微队列的callback2 callback2 callback1 cakkback3 1475 微队列执行完，再执行宏队列的callback1 callback1 callback4 cakkback3 1475 执行callback1中的console3 console3 cakkback3 14752 执行callback1中的Promise2将Promise2的回调任务callback4放入微队列 Promise2 callback4 cakkback3 14752 执行微队列callback4 callback4 cakkback3 147523 执行宏队列callback3 callback3 1475236 执行栈和队列都空，程序执行完毕。 1475236 [!note] 在执行微队列 microtask queue 中任务的时候，如果又产生了 microtask，那么会继续添加到队列的末尾，也会在这个周期执行，直到 microtask queue 为空停止。 当然如果你在 microtask 中不断的产生 microtask，那么其他宏任务 macrotask 就无法执行了，但是这个操作也不是无限的，拿 Node.js 中的微任务 process.nextTick()来说，它的上限是 1000 个，后面我们会讲到。 Node.js 事件循环 执行过程 上一篇我们讲解了 Node.js 的运行原理，讲解了这张图，其中最重要的就是右边的 Libuv 运行图。 Node.js 的 Event Loop 中，执行宏队列的回调任务有6 个阶段，如下图所示。 各个阶段执行的任务如下： timers 阶段：这个阶段执行 setTimeout 和 setInterval 预定的 callback I/O callback 阶段：执行除了 close 事件的 callbacks、被 timers 设定的 callbacks、setImmediate()设定的 callbacks 这些之外的 callbacks idle,prepare 阶段：仅 node 内部使用 poll 阶段：获取新的 I/O 事件，适当的条件下 node 将阻塞在这里 check 阶段：执行 setImmediate()设定的 callbacks close 阶段：执行 socket.on('close', ....)这些 callbacks 上面我们知道，Node.js 中进入宏队列的回调任务有：setTimeout、setInterval 和 setImmediate，微队列的回调任务有：Promise 和 process.nectTick()。 Node.js 中宏队列细分主要有 4 个： Timers Queue IO Callbacks Queue Check Queue Close Callbacks Queue Node.js 中微队列细分主要有 2 个： Next Tick Queue：是放置 process.nextTick(callback)的回调任务的。 Other Micro Queue：放置其他 microtask，比如 Promise 等。 在浏览器中，也可以认为只有一个微队列，所有的微队列的回调任务都会被加到这一个微队列中，但是在 Node.js 中，不同的 microtask 会被放置在不同的微队列中。 具体可以通过下图加深一下理解： [!note] 大体解释一下 NodeJS 的 Event Loop 过程： 执行全局 Script 的同步代码 执行 microtask 微任务，先执行所有 Next Tick Queue 中的所有任务，再执行 Other Microtask Queue 中的所有任务 开始执行 macrotask 宏任务，共 6 个阶段，从第 1 个阶段开始执行相应每一个阶段 macrotask 中的所有任务，注意，这里是所有每个阶段宏任务队列的所有任务，在浏览器的 Event Loop 中是只取宏队列的第一个任务出来执行，每一个阶段的 macrotask 任务执行完毕后，开始执行微任务，也就是步骤 2 Timers Queue -> 步骤 2 -> I/O Queue -> 步骤 2 -> Check Queue -> 步骤 2 -> Close Callback Queue -> 步骤 2 -> Timers Queue ...... 这就是 Node.js 的 Event Loop 练习 1 我们来看一看，下面的代码输出的是什么？ console.log('start'); setTimeout(() => { // callback1 console.log(111); setTimeout(() => { // callback2 console.log(222); }, 0); setImmediate(() => { // callback3 console.log(333); }); process.nextTick(() => { // callback4 console.log(444); }); }, 0); setImmediate(() => { // callback5 console.log(555); process.nextTick(() => { // callback6 console.log(666); }); }); setTimeout(() => { // callback7 console.log(777); process.nextTick(() => { // callback8 console.log(888); }); }, 0); process.nextTick(() => { // callback9 console.log(999); }); console.log('end'); 请运用前面学到的知识，我们可以知道，最终输出的结果如下。 // 正确答案 start; end; 999; 111; // timers 阶段执行输出 777; // timers 阶段执行输出 444; // timers 阶段执行完，执行微队列输出 888; 555; 333; 666; 222; 练习 2 这次，我们加入 Promise 微队列，增加难度。试一试吧。 console.log('1'); setTimeout(function () { console.log('2'); process.nextTick(function () { console.log('3'); }); new Promise(function (resolve) { console.log('4'); resolve(); }).then(function () { console.log('5'); }); }); new Promise(function (resolve) { console.log('7'); resolve(); }).then(function () { console.log('8'); }); process.nextTick(function () { console.log('6'); }); setTimeout(function () { console.log('9'); process.nextTick(function () { console.log('10'); }); new Promise(function (resolve) { console.log('11'); resolve(); }).then(function () { console.log('12'); }); }); 输出结果如下。 1; 7; 6; 8; 2; 4; 9; 11; 3; 10; 5; 12; [!note] setTimeout & setImmediate & process.nextTick setTimeout(fn, 0)在 Timers 阶段执行，并且是在 poll 阶段进行判断是否达到指定的 timer 时间才会执行，回调代码插入到宏队列 Timer Queue中。精确度不高，可能有延迟执行的情况发生，且因为动用了红黑树，所以消耗资源大。 setImmediate(fn, 0)在 Check 阶段执行，回调代码插入到宏队列 Check Queue中。消耗的资源小，也不会造成阻塞，但效率也是最低的。 process.nextTick(fn)在微队列中执行，回调代码插入到微队列 Next Tick Queue 中。process.nextTick(fn)调用深度有限制，上限是 1000，而 setImmedaite 则没有。效率最高，消费资源小，但会阻塞 CPU 的后续调用。 setTimeout(function () { console.log('setTimeout'); }, 延长时间); // 延长时间在[1, 2^31-1]之间，超出区间则默认设置1 setImmediate(function () { console.log('setImmediate'); }, 延长时间); // 延长时间在[1, 2^31-1]之间，超出区间则默认设置1 process.nextTick(function () { console.log('nextTick'); }); setTimeout & setInterval setTimeout(fn, 0)，延迟一定之间去执行，只执行一次。 setInterval(fn, 0)，每隔一定时间就执行，无限次重复执行。 setTimeout 和 setInterval 函数，都返回一个表示计数器编号的整数值，将该整数传入 clearTimeout 和 clearInterval 函数，就可以取消对应的定时器。 let id1 = setTimeout(function () { console.log('setTimeout'); }, 1000); let id2 = setInterval(function () { console.log('setInterval'); }, 1000); setTimeout(() => { clearTimeout(id1); clearInterval(id2); }, 5000); 总结 浏览器的 Event Loop 和 Node.js 的 Event Loop 是不同的，实现机制也不一样，不要混为一谈。 浏览器可以理解成只有 1 个宏任务队列和 1 个微任务队列，先执行全局 Script 代码，执行完同步代码调用栈清空后，从微任务队列中依次取出所有的任务放入调用栈执行，微任务队列清空后，从宏任务队列中只取位于队首的任务放入调用栈执行，注意这里和 Node.js 的区别，只取一个，然后继续执行微队列中的所有任务，再去宏队列取一个，以此构成事件循环。 Node.js 可以理解成有 4 个宏任务队列和 2 个微任务队列，但是执行宏任务时有 6 个阶段。先执行全局 Script 代码，执行完同步代码调用栈清空后，先从微任务队列 Next Tick Queue 中依次取出所有的任务放入调用栈中执行，再从微任务队列 Other Microtask Queue 中依次取出所有的任务放入调用栈中执行。 每个 Macrotask 执行完后，就去执行 Microtask 了，和浏览器的模型一致。 MacroTask 包括： setTimeout、setInterval、 setImmediate(Node)、requestAnimation(浏览器)、IO、UI rendering Microtask 包括： process.nextTick(Node)、Promise、Object.observe、MutationObserver Promise 如何处理 Callback Hell？有很多种方式，但是从来流程程度来看，Promise 还是独领风骚，并且是在 ES6 的 JavaScript 标准上赢得了支持。 关于 Promsie 的基础，这里不再赘述，可以去看前面的 JS 部分。 另外关于同步与异步，有个问题希望大家看一下，这是很简单的 Promise 的使用例子： let doSth = new Promise((resolve, reject) => { console.log('hello'); resolve(); }); doSth.then(() => { console.log('over'); }); 毫无疑问的可以得到以下输出结果。 hello; // 立刻输出 over; // 立刻输出 但是首先的问题是，该 Promise 封装的代码肯定是同步的，那么这个 then 的执行是异步的吗？其次的问题是, 如下代码： let doSth = new Promise((resolve, reject) => { console.log('hello'); resolve(); }); setTimeout(() => { doSth.then(() => { console.log('over'); }); }, 3000); setTimeout 到 10s 之后再 .then 调用, 那么 hello 是会在 10s 之后在打印吗，还是一开始就打印？ 经过实验，我们看到输出结果如下。 hello; // 立刻输出 over; // 3秒后输出 接下来，我们看这个代码： setTimeout(function () { console.log(1); }, 0); new Promise(function executor(resolve) { console.log(2); for (var i = 0; i 最终输出结果是： 2; 3; 5; 4; 1; 说了这么多，其实想告诉大家，Promise 并没有将异步转为同步，只不过是异步回调的语法糖形式而已。Promise 的 resolve 后，状态会改变。然后，会将 then 的回调任务插入到微队列中等待执行。 [!note] Pormise 的 resolve 或 reject 后，状态改变后，并非立即同步执行 then 或 catch 中的回调方法，而是将回调方法插入到微队列中，等待异步方式调用执行。 Events Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 Events 是 Node.js 中一个非常重要的原生模块，在 Node.js 中有许多重要的原生 API 都是依赖其建立的。比如 Stream 是基于 Events 实现的，而 fs、 net、 http 等模块都依赖 Stream，所以 Events 模块的重要性可见一斑。 EventEmitter 类 events 模块只提供了一个对象： events.EventEmitter。 EventEmitter 的核心就是事件触发与事件监听器功能的封装。 可以通过require(\"events\");来访问该模块。 // 引入 events 模块 var events = require('events'); // 创建 eventEmitter 对象 var eventEmitter = new events.EventEmitter(); EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。 下面我们用一个简单的例子说明 EventEmitter 的用法： //event.js 文件 const EventEmitter = require('events').EventEmitter; const event = new EventEmitter(); event.on('execute', function () { console.log('事件触发'); }); setTimeout(function () { event.emit('execute'); }, 1000); 运行这段代码，1 秒后控制台输出了 事件触发。 其原理是 event 对象注册了事件 execute 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 execute，此时会调用 execute 的监听器。 EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 比如，下面的时间，有两个监听器，名字都是 someEvent，当开始执行 someEvent 时，会依次执行。 let { EventEmitter } = require('events'); let emitter = new EventEmitter(); emitter.on('someEvent', function (arg1, arg2) { console.log('listener1', arg1, arg2); }); emitter.on('someEvent', function (arg1, arg2) { console.log('listener2', arg1, arg2); }); emitter.emit('someEvent', 'arg1 参数', 'arg2 参数'); 执行以上代码，运行的结果如下： listener1 arg1参数 arg2参数 // 监听器1的输出 listener2 arg1参数 arg2参数 // 监听器2的输出 以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。 运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是 EventEmitter 最简单的用法。 EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。 Node.js 中 Eventemitter 的 emit 是同步的。Node.js 的官网说明是：The EventListener calls all listeners synchronously in the order in which they were registered. This is important to ensure the proper sequencing of events and to avoid race conditions or logic errors. 继承 EventEmitter 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。 为什么要这样做呢？原因有两点： 具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。 JS 的对象机制是基于原型的，支持 部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。 内部调用 如果一个 EventEmitter 对象，其事件执行中又调用本身事件，是否会陷入死循环呢？ 可对比下面两段代码。 代码 1 const EventEmitter = require('events'); let emitter = new EventEmitter(); emitter.on('myEvent', function sth() { emitter.on('myEvent', sth); console.log('hi'); }); emitter.emit('myEvent'); // 最终输出 // hi（只输出 1 次） 代码 2 const EventEmitter = require('events'); let emitter = new EventEmitter(); emitter.on('myEvent', () => { console.log('hi'); emitter.emit('myEvent'); }); emitter.emit('myEvent'); // 最终输出 // hi（输出 N 次） // RangeError: Maximum call stack size exceeded on 添加绑定事件的时候，会根据是否有过绑定，如果有过绑定，就会将其改成一个 Array\\ emit 的时候，会先用 arrayClone 拿到 Array\\ 的拷贝，遍历调用，如果在 on 里面写多个监听，此时是监听不到的，因为没有被注册进去。 [!note] 使用 emitter 处理问题可以处理比较复杂的状态场景，比如 TCP 的复杂状态机，做多项异步操作的时候每一步都可能报错，这个时候。emit 错误并且执行某些。once 的操作可以将你从泥沼中拯救出来。 另外可以注意一下的是，有些同学喜欢用 emitter 来监控某些类的状态，但是在这些类释放的时候可能会忘记释放 emitter，而这些类的内部可能持有该 emitter 的 listener 的引用从而导致内存泄漏。 Timers 定时器 setTimeout setTimeout(fn, 0)在 Timers 阶段执行，并且是在 poll 阶段进行判断是否达到指定的 timer 时间才会执行，回调代码插入到宏队列 Timer Queue中。精确度不高，可能有延迟执行的情况发生，且因为动用了红黑树，所以消耗资源大。 setImmediate setImmediate(fn, 0)在 Check 阶段执行，回调代码插入到宏队列 Check Queue中。消耗的资源小，也不会造成阻塞，但效率也是最低的。 process.nextTick process.nextTick(fn)在微队列中执行，回调代码插入到微队列 Next Tick Queue 中。process.nextTick(fn)调用深度有限制，上限是 1000，而 setImmedaite 则没有。效率最高，消费资源小，但会阻塞 CPU 的后续调用。 并行/并发 并行 (Parallel) 与并发 (Concurrent) 是两个很常见的概念。关于并行和并发，可以看这张漫画图。 并发 (Concurrent) = 2 队列对应 1 咖啡机。 并行 (Parallel) = 2 队列对应 2 咖啡机。 Node.js 通过事件循环来挨个抽取事件队列中的一个个 Task 执行，从而避免了传统的多线程情况下（2 个队列对应 1 个咖啡机的时候）上下文切换以及资源争抢/同步的问题，所以获得了高并发的成就。 至于在 Node.js 中并行，你可以通过 cluster 来再添加一个咖啡机。 热更新 对于开发者来说，我们在开发过程中都希望文件修改后，能够自动更新，而不必每次都重启服务，这就是所谓的“热更新”（或者叫“热加载”）。 对于启动的 Node.js 服务来说，其模块已经加载到缓存中了，当我们在磁盘上改动了文件模块后，该启动服务是无法更新的，这时候我们就需要监听某些文件，当文件被修改后，则自动将该文件对应的模块从 module cache 上清除，这样，当执行 require 时，在缓存中找不到对应的模块，就会重新从新代码中重新编译加载并缓存。 模拟实验 下面，我们就根据原理来模拟实现以下热更新操作。我们新建一个模拟热更新的文件hot-patch.js，其内容如下： const fs = require('fs'); //文件系统模块 function cleanCache(modulePath) { const module = require.cache[modulePath]; if (!module) { return; } // 该模块是否有主模块 // module.parent 在 Node.js v14 版本后被弃用 if (module.parent) { module.parent.children.splice(module.parent.children.indexOf(module), 1); } require.cache[modulePath] = null; } const watchFile = function (filepath) { // require.resolve() 返回该模块完整的文件名 const fullpath = require.resolve(filepath); // fs.watch() 监听文件事件 fs.watch(fullpath, function (event, filename) { if (event === 'change') { try { cleanCache(fullpath); } catch (ex) { console.error('模块加载失败'); } } }); }; // 热更新 function startHotPatch() { const watchFiles = ['./test.js']; for (let i = 0; i 对于test.js，其文件内容如下： module.exports = '123'; 然后，我们执行node hot-patch.js启动程序，然后当我们改变test.js的文本内容时，我们可以发现，输出也会随之改变。 上面就是热更新的模拟示例。 nodemon 库 对于 Node.js 开发来说，常见的热更新方式是借助nodemon库实现，它能够监听文件的修改，并在文件修改后做出响应。 常用命令 # 启动程序 nodemon [your node app] # 如果程序启动可传入host和port，也可以通过这种方式启动 nodemon ./server.js localhost 8080 nodemon.json 配置文件 nodemon 支持 local 和 global 配置文件，配置文件名称为nodemon.json，可以通过--config 来指定配置文件。启动命令中携带的参数都可以在配置文件中配置，比如： { \"verbose\": true, \"ignore\": [\"*.test.js\", \"fixtures/*\"], // 忽略监听的文件 \"ext\": \"js,json\", // 监听文件的拓展名 \"env\": { \"NODE_ENV\": \"development\" }, \"execMap\": { \"rb\": \"ruby\", // 支持 ruby 文件的处理 \"pde\": \"processing --sketch={{pwd}} --run\" // 支持 pde 文件的处理 } } 更多详细功能，可前往nodemon 官网查看。 上下文 在 JavaScript 篇章，我们已经学习了执行上下文。 对于 Node.js 而言，正常情况下只有一个上下文，甚至于内置的很多方面例如 require 的实现只是在启动的时候运行了内置的函数。 每个单独的 JS 文件并不意味着单独的上下文，在某个 JS 文件中污染了全局的作用域一样能影响到其他的地方（JS 文件中的局部变量仍然不受影响）。 而目前的 Node.js 将 VM 的接口暴露了出来，可以让你自己创建一个新的 js 上下文，这一点上跟前端 JS 还是区别挺大的。在执行外部代码的时候，通过创建新的上下文沙盒 (sandbox) 可以避免上下文被污染。 [!note] vm 模块可在 V8 虚拟机上下文中编译和运行代码。vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 JavaScript 代码可以被立即编译并运行，也可以编译、保存并稍后运行。 一个常见的用例是在不同的 V8 上下文中运行代码。 这意味着被调用的代码与调用的代码具有不同的全局对象。 可以通过使对象上下文隔离化来提供上下文。 被调用的代码将上下文中的任何属性都视为全局变量。 由调用的代码引起的对全局变量的任何更改都将会反映在上下文对象中。 const vm = require('vm'); const x = 1; const context = { x: 2 }; vm.createContext(context); // 上下文隔离化对象。 const code = 'x += 40; var y = 17;'; // x 和 y 是上下文中的全局变量。 // 最初，x 的值为 2，因为这是 context.x 的值。 vm.runInContext(code, context); console.log(context.x); // 42 console.log(context.y); // 17 console.log(x); // 1 // console.log(y); // ReferenceError: y is not defined [!warning] Node.js 为什么不给每个单独的 JS 文件分配单独的上下文，这样就避免了作用域污染问题？ 对于这个问题，其实就是 Node.js 的模块引用机制。我们都知道，Node.js 采用 CommonJS 规范，在运行 JS 文件时，每个 JS 文件都是被包裹在一个函数中运行的，即每个模块都是独立的上下文。所以，正常情况下，每个模块内的变量都只是其内部变量，都只作用在该模块内部，并不存在作用域污染的问题。 非正常情况就是，不小心漏写了var 定义成了全局变量，对于这个问题，只能严格模式来避免。 // 添加 'use strict'; 'use strict'; globalVar = 1; // 禁止这样意外创建全局变量，代码执行时将抛出 globalVar 未定义的错误 Node.js 管理器 NPM 包管理器 npm的全称是 Node Package Manager，是随同 NodeJS 一起安装的包管理和分发工具，它很方便让 JavaScript 开发者下载、安装、上传以及管理已经安装的包。 在 2017 年 1 月时，npm 仓库中就已有超过 350000 个软件包，这使其成为世界上最大的单一语言代码仓库，并且可以确定几乎有可用于一切的软件包。 它起初是作为下载和管理 Node.js 包依赖的方式，但其现在也已成为前端 JavaScript 中使用的工具。 常用的 npm 命令如下所示。 # 安装所有依赖 # package.json文件中的依赖自动安装到node_modules文件夹中 npm i # 安装特定软件包 npm i express # 安装 express 包 npm i express@1.0.0 # 安装指定版本的 express 包 npm i express -D # 安装 express 包，并保存在package.json的devDependencies中 npm i express -S # 安装 express 包，并保存在package.json的dependencies中 npm i express -g # 安装 express 包到全局环境 # 卸载软件包 npm uninstall express # 更新软件包 npm update express # 检查软件包是否过时 npm outdated # 查看安装的模块 npm ls # 初始化项目 npm init # 查看包安装路径 npm root # 输出当前项目的 node_modules 路径 npm root -g # 全局 node_modules 路径 # 缓存 npm cache clean # 清除缓存 # 发布模块 npm publish # 本地链接模块 npm link # theme-lou项目中执行，模块link到该项目文件夹中 npm link theme-lou # 需要依赖的项目中执行，则链接到上一条命令的项目中 NVM 版本管理 在我们的日常开发中经常会遇到这种情况：手上有好几个项目，每个项目的需求不同，进而不同项目必须依赖不同版的 Node.js 运行环境。如果没有一个合适的工具，这个问题将非常棘手。 nvm就应运而生，全称是 Node Version Manager。nvm 是 Mac 下的 node 管理工具，有点类似管理 Ruby 的 rvm，如果需要管理 Windows 下的 node，官方推荐使用 nvmw 或 nvm-windows。不过，nvm-windows 并不是 nvm 的简单移植，他们也没有任何关系。但下面介绍的所有命令，都可以在 nvm-windows 中运行。 常用的 nvm 命令如下所示。 # 安装指定版本的 Node.js nvm install 12.16 nvm install 10.23.0 # 切换 Node.js 版本 nvm use 12.16 # 列出版本 nvm list/ls # 版本命名 nvm alias node12 12.16 # node12就指代12.16版本 nvm unalias node12 # 取消指代 # 设置默认的版本 nvm alias default 10.23.0 # 查找安装路径 nvm which 10.23.0 # 查找某个版本的路径 # 快捷命令 nvm install node # 安装最新版 Node nvm install unstable # 安装最新不稳定版本 Node "},"Chapter2/2.html":{"url":"Chapter2/2.html","title":"二、Node.js 核心","keywords":"","body":"Node.js 核心 参考文章https://github.com/ElemeFE/node-interview/tree/master/sections/zh-cn 网络通信 Linux五种网络模型 前面讲到Node.js的特点有两个：事件驱动和异步IO。当时，提及“在Node.js中，异步IO也称为非阻塞IO”。其实，这句话是不准确的，因为在Linux系统的网络IO模型中，异步IO和非阻塞IO分别是两种东西。 接下来，我们以Richard Stevens的《UNIX® Network Programming》一书为参考，来学习网络模型。该书中，网络模型一共有5种： blocking IO：阻塞IO。 non-blocking IO：非阻塞IO。 IO multiplexing：IO复用。 signal driven IO：信号驱动IO。 asynchronous IO：异步IO。 其中，前四个都是同步IO，最后一个是异步IO。 IO其实我们并不陌生，站在操作系统的角度上说，IO一般指访问磁盘数据，网络IO只不过它是读取的不是磁盘，而是socket。 一般IO操作可以分为两步，以read操作举例来说： 等待数据准备 (Waiting for the data to be ready)。 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。 由此可见，IO操作它会涉及到两个系统对象，一个是调用这个IO的进程 (或线程)，另一个就是系统内核。 阻塞IO 场景描述 我在餐馆点餐，点完后就一直等着菜上来，什么事情也不做。菜上来后，等待结束，继续吃饭或拍照，做其他事情。 网络模型 同步阻塞 IO 模型是最常用的一个模型，也是最简单的模型。在Linux中，默认情况下所有的socket都是blocking。它符合人们最常见的思考逻辑。阻塞就是进程 \"被\" 休息，CPU处理其它进程去了。 当用户进程调用了recv()/recvfrom()这个系统调用，Kernel就开始了IO的第一个阶段：准备数据。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当Kernel一直等到数据准备好了，它就会将数据从Kernel中拷贝到用户内存，然后Kernel返回结果，用户进程才解除block的状态，重新运行起来。 非阻塞 IO 场景描述 我在餐馆点餐，点完后我没有暂停，而是做其他的事情，每隔1分钟都来询问服务员菜好了没有。 网络模型 同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。 当用户进程发出read操作时，如果Kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦Kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 IO复用 IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。 select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 场景描述 去餐厅点餐后，用户需要不断的询问服务员菜是否准备好。现在，IO复用就是找一个黄牛，黄牛提前告诉服务员我要点的菜菜，然后黄牛来监控菜是否准备好。当菜准备好以后，我直接来告诉让服务员把菜端上来。 网络模型 由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。 当用户进程调用了select，那么整个进程会被block，而同时，Kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 IO多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，IO多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源。 信号驱动IO 该模型不常见，可以忽略。 该模型允许socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。 异步IO 相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。 场景描述 我在餐厅点餐，点好后我完全不用管，继续做其他的事情。等餐做好了以后，服务员会直接端过来。 网络模型 用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。 总结 阻塞与非阻塞：调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 同步和异步：同步和异步主要的区别在于是否存在阻塞。阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO。 各种IO模型的比较如图所示。 网络通信协议 在网络历史的早期，国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)共同出版了开放系统互联的OSI七层参考模型。一台计算机操作系统中的网络过程包括从应用请求(在协议栈的顶部)到网络介质(底部) ，OSI参考模型把功能分成七个分立的层次。完整的七层通信理论模型，如下图所示。 发送方由第七层到第一层由上到下按照顺序传送数据，每个分层在处理上层传递的数据时，附上当前层协议所必须的 “首部”信息。接收方由第一层到第七层由下到上按照顺序传递数据，每个分层对接收到的数据进行“首部”与“内容”分离，在转发给上一层。最终将发送的数据恢复为原始数据。 然而，实际生产中使用的是TCP/IP四层模型，两者的关系及每层对应的协议如下表所示。 OSI七层模型与TCP/IP四层模型 OSI七层模型 TCP/IP四层模型 相关协议 设备应用 应用层 应用层 TCP支持：Telnet、FTP、SMTP、HTTPS、HTTPUDP支持：NFS、SNMP、DNS、TFTP 应用程序 表示层 会话层 传输层 传输层 TCP、UDP 操作系统 网络层 网际层 IP、ICMP 数据链路层 网络接口层 PPP、Etherent 驱动程序与网络接口 物理层 TCP协议 Transmission Control Protocol，传输控制协议。是一种可靠的，面向连接的协议。在发送数据前，必须与对方建立连接通道，传输效率低。 ![note] 有连接协议 发送数据之前，需要在收发主机之间建立一条通信线路，在通信传输前后，专门进行建立和断开连接的处理，如果与对端之间无法通信，可避免发送无谓的数据。 TCP报文首部 TCP报文的首部由20个字节固定字节和4n(n取[0~5]整数)个可变的选项字节组成，其中固定部分的各字段含义如下： 源端口和目的端口：各占2个字节，分别写入通信双方进程端口号 序号seq：占4个字节。在TCP连接中，传送的字节流中的每一个字节都是要按顺序编号[0~232-1]，整个要传送的字节流的起始序号在必须连接建立时设置，序号字段值代表本报文段所发送的数据的第一个字节的序号 确认号ack：占4个字节，是期望收到对方的下一个报文段的第一个数据字节的序号，即ack=N,就代表了到序号N-1为止的所有数据都被正确接收了。 数据偏移：占4位，表示TCP报文的数据部分起始处距离TCP报文首部的起始处有多远，数据偏移值的单位是32位字（以4字节为计算单位），4位二进制能表示的值[0~15],这就意味着TCP首部最大长度为60字节，也就是选项部分的最大长度为40字节。 保留位：占6位，保留为以后使用，目前置为0 控制位：占6位，每个控制字段占1位，它们的标识和含义是： 紧急URG：URG=1时，告诉系统此报文中有紧急数据，优先传送，与紧急指针配合使用 确认ACK：当ACK=1时，确认号才有效，ACK=0时，确认号无效，TCP连接建立后，所有报文ACK必须都为1 推送PSH：发送方把PSH置为1，接收方收到报文后会尽快交付，不用等缓存填满了再交付 复位RST：当RST=1时，表明TCP连接出现了严重差错，必须释放连接，然后重新建立新运输连接。RST=1还可以用来拒接一个非法报文段或拒绝打开一个连接。 同步SYN：在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文段，对方若同意建立连接，则需要在响应报文中使SYN=1和ACK=1 终止FIN：用来释放一个连接 。当FIN=1时，表明此报文段的发送方数据已经发送完毕，并且要求释放运输连接。 窗口：占2字节，窗口值是[0~216-1]之间的整数。窗口值告诉了对方，从本报文段的确认号算起，允许对方发送的数据量。 检验和：占2字节，用于接收方检验首部和数据部分是否在传输中有差错，类似我们下载文件时的Md5签名校验作用。 紧急指针：占2字节，URG=1时才起作用，用于指明本报文段中的紧急数据的字节数，紧急数据结束后就是普通数据，所以紧急指针指出了紧急数据的末尾在报文中位置。 选项：长度可变，最小0字节，最长达40字节。首部用来动态存储数据。 三次握手建立连接 TCP建立连接采用的是C/S模式，C指的就是Client客户端，S指的是Server服务器。TCP连接的过程如下图所示。 默认情况下客户端Client和服务端Sever的TCP进程都处于CLOSED（关闭）状态。 服务端TCP服务进程先建立传输控制块TCB，然后服务端进入LISTEN（监听）状态，等待客户端连接请求。 握手 数据 描述 第一次握手 SYN=1seq=x（随机） 客户端TCP进程也先建立传输控制块TCB，然后向服务端发送连接请求报文段，此时SYN=1,随机选定一个初始序号seq=x，此报文不能携带数据，但是要消耗掉一个序号，发送完毕后，客户端进入SYN-SENT（同步已发送）状态 第二次握手 SYN=1ACK=1ack=x+1seq=y 服务端收到客户端请求连接报文段后，若同意建立连接，则发送确认报文，确认报文中SYN=1、ACK=1,确认号ack=x+1,同时随机选定一个自己序号seq=y,确认报文段同样不能携带数据，但是也要消耗掉一个序号，发送完毕后服务端进入SYN-RCVD（同步收到）状态 第三次握手 ACK=1ack=y+1seq=x+1 客户端收到确认报文后，检查ACK=1，ack=x+1是否正确，若正确，则向服务端发送确认报文，确认报文中ACK=1,ack=y+1,seq=x+1,发送后进入ESTAB-LISHED状态，服务端收到确认报文后，也进入ESTAB-LISHED状态，此时双方TCP连接正式建立。 UDP协议 User Datagram Protocol，用户数据报协议。是一种不可靠的、无连接的协议。传输效率高。 [!note] 无连接协议 无需确认对方是否存在，随时发送数据。 TCP协议 测试 压力测试 "},"Chapter3/":{"url":"Chapter3/","title":"第三章 构建前端页面","keywords":"","body":" 构建前端页面 床前明月光， 这篇还没上。 举头望明月， 再等一个月。 "},"Chapter4/":{"url":"Chapter4/","title":"第四章 开发后端服务","keywords":"","body":" 开发后端服务 床前明月光， 这篇还没上。 举头望明月， 再等一个月。 "},"Chapter5/":{"url":"Chapter5/","title":"第五章 接口中间件","keywords":"","body":" 接口中间件 床前明月光， 这篇还没上。 举头望明月， 再等一个月。 日志存储、接口鉴权 "},"Chapter6/":{"url":"Chapter6/","title":"第六章 Mysql 存储","keywords":"","body":" Mysql 安装和配置 "},"Chapter6/1.html":{"url":"Chapter6/1.html","title":"Mysql 安装和配置","keywords":"","body":"Mysql 存储 一、安装 Mysql 1、删除存在的 mysql rpm -qa|grep mysql rpm -e mysql mysql-libs yum -y remove mysql-server mysql mysql-libs 2、配置源 # 下载rpm软件包管理器 wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm # 配置源 rpm -ivh mysql57-community-release-el7-9.noarch.rpm # 查看源是否配置 yum repolist enabled | grep \"mysql.*-community.*\" 3、安装 Mysql 注意，默认安装源之后自动开启 5.7 系列的安装。如果你要安装的 MySQL 低于 5.7 需要改源。。 # 安装社区版 yum install mysql-community-server 二、启动 Mysql 1、执行启动命令 # 启动mysql service mysqld start 2、其他命令 # 查看启动状态 service mysqld status # 重启 service mysqld restart # 停止 service mysqld stop 三、权限配置 1、修改密码 Mysql 首次启动会，会生成一个临时密码，通过命令来查看。 grep 'temporary password' /var/log/mysqld.log 可以看到，临时密码是“k+)!R(VPs3F+”。 2、使用临时密码进入 mysql 服务 # root账户登录 mysql -uroot -p # 输入密码 k+)!R(VPs3F+ 3、重置密码 进入数据库后，在执行操作前，必须重置密码。 # 查看数据库 show databases; 设置密码。 # 设置密码 set password = password('8位密码，包括大写、小写、数字和特殊符号'); 4、查看用户 # 切换到mysql数据库 use mysql; # 查看user表信息 select host,user from mysql.user; 5、添加新用户和数据库 # 添加新用户，允许外网访问 create user 'aquaman'@'%' identified by '密码'; # 添加成功后，刷新授权 flush privileges; # 创建数据库 create database aquaman DEFAULT CHARSET utf8 COLLATE utf8_general_ci; # 将改用户赋权给数据库，并刷新授权 grant all privileges on aquaman.* to 'aquaman'@'%' identified by '密码' with grant option; # 刷新授权 flush privileges; # 更改用户名 update user set user ='aquaman' where user ='nodejs'; 本地即可连接 Mysql 数据库，连接成功后，只能够有权限管理 nodejs 库，其他库无法查看。 补充 rpm 是一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。 # 配置源 rpm -i xxx.rpm # 删除配置 rpm -e mysql80-community-release-el8-1.noarch "},"Chapter7/":{"url":"Chapter7/","title":"第七章 Mongodb 存储","keywords":"","body":" Mongodb安装和配置 "},"Chapter7/1.html":{"url":"Chapter7/1.html","title":"Mongodb 安装和配置","keywords":"","body":"Mongodb安装和配置 一、安装Mongodb 在这个MongoDB教程中，我们将解释如何在CentOS 7上安装数据库，然后提供一些基本特性和功能的简短指南。 1、添加MongoDB源 CentOS7不包括Mongodb源，所以需要自行添加。 # 创建文件 vi /etc/yum.repos.d/mongodb-org-4.2.repo 2、复制下面内容到文件中 [mongodb-org-4.2] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc 3、执行安装 # yum安装 yum install -y mongodb-org 二、配置Mongodb配置 1、修改配置文件的 bind_ip, 默认是 127.0.0.1 只限于本机连接。 # 编辑配置文件 vi /etc/mongod.conf # 更改bind_ip bind_ip 0.0.0.0; # 0.0.0.0任何IP均可访问（为方便开发，生产环境无用！！！） # 查看版本号 mongod --version 三、权限 mongodb 操作前，先use 数据库，选择对应的数据库，然后 db.auth(\"admin\", \"密码\")才能够进行操作。 # 进入mongo mongo # 切换到admin库 use admin # 创建用户（role角色很多种） db.createUser({ user: \"admin\", pwd: \"密码\", roles: [{ role: \"dbOwner\", db: \"admin\" }] }) # 验证 db.auth(\"admin\", \"密码\") # 给用户赋予角色 db.grantRolesToUser(\"admin\", [ { role:\"dbAdminAnyDatabase\", db:\"admin\"} ]); # 回收用户角色 db.revokeRolesFromUser(\"admin\", [ { role:\"dbAdminAnyDatabase\", db:\"admin\"} ]); # 更改用户密码 db.changeUserPassword('admin','aD0aG1aA1eB2fA2l'); 四、常用命令 # 启动 service mongod start # Redirecting to /bin/systemctl start mongod.service # 所以，可以直接用 systemctl 命令 mongod.service 格式来执行各种命令 # 停止 service mongod stop # 重启 service mongod restart # 设置开机启动 chkconfig mongod on # 查看日志（日志文件地址为config配置） cat /var/log/mongodb/mongod.log # 开启外网访问权限 mongod --bind_ip_all # 进入mongo数据库 mongo # 查看数据库 show dbs; # 查看数据库版本 db.version(); # 常用命令帮助 db.help(); "},"Chapter8/":{"url":"Chapter8/","title":"第八章 Redis 存储","keywords":"","body":" Redis安装和配置 "},"Chapter8/1.html":{"url":"Chapter8/1.html","title":"Redis 安装和配置","keywords":"","body":"Redis存储 一、安装Redis 在本节中，您将添加EPEL存储库，然后使用它来安装Redis。 1、添加EPEL存储库，并更新YUM以确认您的更改 # 安装EPEL存储库 yum install epel-release # 安装redis yum install redis 2、启动redis # 启动服务 systemctl start redis # 验证redis是否启动，返回PONG表示启动 redis-cli ping # 重启服务 systemctl restart redis 二、配置Redis Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。 # 查看redis安装包 rpm -qa|grep redis # 找redis安装位置 rpm -ql redis-3.2.10-2.el7.x86_64 发现，redis.conf文件在/etc目录下。 # 查看所有配置 CONFIG GET * # 查看某一配置 CONFIG GET 配置名 # 编辑配置 CONFIG set 配置名 配置值 三、Redis命令 # 启动redis客户端 redis-cli # 授权 auth 密码 # 检查是否启动 PING # 存值 set foo bar # 取值 get foo "}}