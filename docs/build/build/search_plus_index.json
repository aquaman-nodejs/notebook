{"./":{"url":"./","title":"简介","keywords":"","body":" @media (min-width: 768px){ .markdown-section #book-cover { max-width: 80% !important; max-height: 460px; } } @media (max-width: 768px){ .markdown-section #book-cover { max-width: 100% !important; max-height: 460px; } } .book-anchor { display: none; } .page-inner { padding: 20px 40px 20px 40px; } "},"Foreword/":{"url":"Foreword/","title":"序言","keywords":"","body":"不自动编号 前言 Node.js 学习教程，主要讲解 JS 语言、Node.js 框架、前后端开发、数据库、消息队列、监控、桌面应用和运维部署等内容，帮助初学者更好的学习 Node.js 开发。 关于作者 松露 🎓 华东师范大学软件工程硕士 📡 信息系统项目管理工程师 🌍 个人主页 星河 🎓 郑州大学计算机科学与技术专业 📡 系统架构师 🌍 个人主页 所有内容均为作者整理发布。如有错误，欢迎指正。 版权说明 本项目采用 MIT License 进行许可。未经作者授权，请勿用于商业用途！ "},"Chapter1/":{"url":"Chapter1/","title":"第一章 JS 语法","keywords":"","body":" JS 语法 JavaScript 是属于 HTML 和 Web 的编程语言。 编程令计算机完成您需要它们做的工作。 JavaScript 很容易学习。 本教程涵盖 JavaScript 基础和高级教程。 一、JS 基础 二、JS 进阶 "},"Chapter1/1.html":{"url":"Chapter1/1.html","title":"一、JS 基础","keywords":"","body":"JS 基础 JavaScript 是 Web 的编程语言。 所有现代的 HTML 页面都使用 JavaScript。 JavaScript 非常容易学。 数据类型 基本类型 引用类型 ● 字符串 String● 数字 Number● 布尔 Boolean● 对空 Null● 未定义 Undefined●Symbol ● 对象 Object● 数组 Array● 函数 Function● 日期 Date● 正则 RegExp [!note] Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。 typeof JavaScript 是一门弱语言，它在声明变量时无需确定变量的类型，JavaScript 在运行时会自动判断。 那么如何判断一个变量的类型呢？JavaScript 提供了typeof运算符，用来检测一个变量的类型。 使用方法 typeof 表达式; // 或 typeof 变量; 返回值 示例 返回值 说明 typeof undefined \"undefined\" 未定义的变量或值 typeof true \"boolean\" 布尔类型 typeof \"123\" \"string\" 字符串 typeof 123 \"number\" 数值 typeof []typeof {} \"object\" null 值数组JS 对象 typeof console.logtypeof function(){} \"function\" 函数 动态类型 JavaScript 拥有动态类型。这意味着相同的变量可用作不同的类型： var x; // x 为 undefined var x = 5; // 现在 x 为数字 var x = 'John'; // 现在 x 为字符串 Undefined 和 Null Undefined：表示变量“缺少值”，即这地方应该有值，但是目前还没有定义值。 Null：表示变量有值，值为“空”。可以通过将变量的值设置为 null 来清空变量。 undefined == null; // true undefined === null; // false typeof undefined; // \"undefined\" typeof null; // \"object\" Number(undefined); // NaN Number(null); // 0 变量提升 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。 JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。 以下两个实例将获得相同的结果： // 实例1 x = 5; // 变量 x 设置为 5 elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x; // 在元素中显示 x var x; // 声明 x // 实例2 var x; // 声明 x x = 5; // 变量 x 设置为 5 elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x; // 在元素中显示 x JavaScript 只有声明的变量会提升，初始化的不会。 以下两个实例结果结果不相同： // 实例1 var x = 5; // 初始化 x var y = 7; // 初始化 y elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x + ' ' + y; // 显示 x 和 y // 实例2 var x = 5; // 初始化 x elem = document.getElementById('demo'); // 查找元素 elem.innerHTML = x + ' ' + y; // 显示 x 和 y，y 为 undefined var y = 7; // 初始化 y 变量定义 var 的 bug Js 没有块级作用域。 请看这样一条规则：在 JS 函数中的 var 声明，其作用域是函数体的全部。 // 明明已经跳出 for 循环了，却还可以访问到 for 循环内定义的变量 a ，甚至连 i 都可以被放访问到，尴尬~ for (var i = 0; i 循环内变量过度共享。 在浏览器里运行一下，看看和你预想的结果是否相同？ 没错，控制台输出了 3 个 3，而不是预想的 0、1、2。 事实上，这个问题的答案是，循环本身及三次 timeout 回调均共享唯一的变量 i 。 当循环结束执行时，i 的值为 3。所以当第一个 timeout 执行时，调用的i 当让也为 3 了。 for (var i = 0; i 话说到这儿，想必客官已经猜到 let 是干嘛用的。 你没猜错，就是解决这两个 bug 的。 你尽可以把上述的两个例子中的 var 替代成 let 再运行一次。 [!node] 必须声明 'use strict' 后才能使用 let 声明变量，否则浏览并不能显示结果。 let 定义变量 let 声明的变量拥有块级作用域。 let 声明的全局变量不是全局对象的属性。 形如 for (let x...)的循环在每次迭代时都为 x 创建新的绑定。 用 let 重定义变量会抛出一个语法错误（SyntaxError）。 let a = 'a'; let a = 'b'; // Uncaught SyntaxError: Identifier 'a' has already been declared const 定义常量 ES6 引入的第三个声明类关键词：const。const 就是用来定义常量的。 // 下面程序会报错 // a是一个常量，不能被赋值。 const a = 1; a = 2; // Uncaught TypeError: Assignment to constant variable. // 下面程序却不会报错 // a虽然是常量，但是一个对象，存的是地址不是值 const a = {}; a['key'] = 'value'; 对象 JavaScript 对象是拥有属性和方法的数据。 生活中，一辆汽车是一个对象。 对象有它的属性，如重量和颜色等，方法有启动停止等。 [!note] 在 JavaScript 中，对象是非常重要的，当你理解了对象，就可以了解 JavaScript 。 JavaScript 对象是变量的容器。 var person = { firstName: 'John', lastName: 'Doe', fullName: function () { return this.firstName + ' ' + this.lastName; }, }; person.fullName(); // 返回 John Doe String 字符串对象 JavaScript 字符串是原始值，可以使用字符创建： var firstName = \"John\" 但我们也可以使用 new 关键字将字符串定义为一个对象： var firstName = new String(\"John\") var x = 'John'; var y = new String('John'); typeof x; // \"string\" typeof y; // \"object\" [!danger] 不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用。 Number 数字对象 var x = 1; var y = new String(1); typeof x; // \"number\" typeof y; // \"object\" Date 日期对象 const now = new Date(); // Sun Mar 28 2021 16:15:47 GMT+0800 (中国标准时间) now.getFullYear(); // 年 2021 now.getMonth(); // 月 2 从0开始index，2index表示3月 now.getDate(); // 日 28 now.getDay(); // 星期 0 从0开始，星期天是0 now.getHours(); // 时 16 now.getMinutes(); // 分 15 now.getSeconds(); // 秒 47 now.getMilliseconds(); //毫秒 498 Array 数组对象 常用对象方法。 方法 描述 concat() 连接 2 个及以上的数组，返回新的数组 copyWithin(2, 0) index2 赋值为 index0index3 赋值为 index1 every() 检测数组所有元素是否都符合指定条件（通过函数提供）。返回 true、false fill(value, start, end) 用一个固定值，从 start 开始到 end 截止填充 findIndex() 返回符合条件的第一个元素的 index lastIndexOf() 返回符合条件的最后一个元素的 index find() 返回符合条件的第一个元素 filter() 返回符合条件的所有元素 indexOf() 某值在数组中的 index不存在为-1 join(separator) 数组合并为字符串，用separator分隔符连接 shift() 删除数组的第一个元素并返回删除的元素 pop() 删除数组的最后一个元素并返回删除的元素 push() 向数组的末尾添加一个或更多元素，并返回新的长度 reverse() 数组反转 slice() 截取一部分，返回新数组 Boolean 布尔对象 Boolean（布尔）对象用于将非布尔值转换为布尔值（true 或者 false）。 // false 相等的几种情况 0 == false; // true -0 == false; // true '' == false; // true // false 不等的几种情况 undefined == false; // false NaN == false; // false null == false; // false Math 算术对象 属性 描述 Math.PI 返回圆周率（约等于 3.14159） Math.E 返回算术常量 e，即自然对数的底数（约等于 2.718） LN10 返回 10 的自然对数（约等于 2.302） LN2 返回 2 的自然对数（约等于 0.693） 对象 描述 Math.abs(x) x 的绝对值 Math.random() 0~1 之间的数 Math.ceil(x) 向上取整 Math.floor(x) 向下取整 Math.round(x) 四舍五入 Math.sqrt(x) 计算平方根 Math.max(x1, x2,...,xn) 最大值 Math.min(x1, x2,...,xn) 最小值 Math.pow(x,y) x 的 y 次方 RegExp 正则对象 // 下面两个是等价的 var re1 = new RegExp('\\\\w+'); var re2 = /\\w+/; Error 错误对象 Error 对象在错误发生时提供了错误的提示信息。 运行时错误实例会由执行引擎自动创建和抛出，我们也可以通过构造函数自定义Error实例，与其它类一样我们也可以通过Error.prototype向实例中添加属性和方法。 Error实例包含以下属性或方法： Error.prototype.constructor － 指定对象的构造函数 Error.prototype.message － 错误信息 Error.prototype.name － 错误名 Error.prototype.stack － 错误堆栈信息。该属性是一个非标准属性，但被大多数执行引擎所支持。 Error.prototype.toString() － 表示错误对象的描述信息。继承并重写Object.prototype.toString() 错误类型： EvalError ：Eval 错误，对象表示全局函数eval()中发生的错误。 ReferenceError：引用错误，错误对象会在引用未定义的变量时触发。 RangeError：范围错误，错误对象会在值超过有效范围时触发。 SyntaxError：语法错误，错误对象会使用不合法的语法结构时触发。 TypeError：类型错误，错误会在对象用来表示值的类型非预期类型时触发。 URIError：URI 错误，错误会错误使用全局 URI 函数如encodeURI()、decodeURI()等时触发 this 关键字 面向对象语言中 this 表示当前对象的一个引用。 但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。 在方法中，this 表示该方法所属的对象。 如果单独使用，this 表示全局对象。 在函数中，this 表示全局对象。 在函数中，在严格模式下，this 是未定义的(undefined)。 在事件中，this 表示接收事件的元素。 类似 call() 和 apply() 方法可以将 this 引用到任何对象。 开发规范 代码规范 通用性 代码和 bug 总是形影不离的。减少 bug 的最好方式就是减少代码本身。用更少的代码完成同样的任务迫使你投入更多的时间思考和设计。更少的代码更易于维护，因为你要读的代码更少。更少的代码还带来了一致性。想象一下如果同样的逻辑在 3 处重复了 3 遍，当你修改时你可能只改了 1 处，不一致就产生了。 关于重用性有一种思想误区：库的代码才需要有重用性，我的代码不需要，因为没人会重用我的代码。重用性是一种写代码时的思考方式，应该成为一种写代码的习惯。就算没有别人会重用你的代码，你自己也要重用你的代码。 职责划分清楚 为了使代码具备重用性，很重要的一个因素就是职责划分。通俗一点讲就是“管好你该管的事，不要管你不该管的事”。如果一段代码的职责是调用发送邮件，那它就做好这件事。至于使用这个 api 的人是谁，在什么场景使用，都不是这个 api 该管的事。如果一个功能需要 300 行代码来完成，我们该如何去划分职责？又该如何去把这些代码归类放到哪些函数/类/文件中呢？这时候你就要在脑中形成几个各自独立的模块，把功能相关的代码聚到一起放在一个模块中。同时还要思考模块之间的接口如何定义。比如我们要处理一个商品被购买后发货的处理。这时你大概就可以在脑中模糊地形成这么几个模块：商品、订单、支付、物流。然后再去细想各个模块的职责边界在哪。模块之间的交互是怎样的。如果商品模块里有订单的内部逻辑代码，然后订单模块里有顺丰物流的 api 细节。很快你就会发现这些模块很难被重用了。 代码分层 任何复杂的事情都是通过分层来降低认知和管理的难度。国家分为省、市、区、镇。学校按照年级和班级划分。写文章也要有开头、中间和收尾，每一部分又可以再分几个步骤。互联网分了 4 层，各司其职，应用层不用去担心物理层。写代码也是一样。逻辑是要一层一层展开，而不是 500 行代码平铺在一个函数里。 可读性 代码的可读，有个硬性的规定，就是每个功能函数的行数不宜过多，一方面要保证函数的结构紧凑，另一方面也便于后期的单元测试。 避免多次 callback 回调或多次嵌套 if 判断 callback 由于 async 和 promise 的使用，callbck hell 出现的情况不太多。但是，if 的多层判断，一定会经常的出现，所以，做判断的时候，要注意，不要一直嵌套嵌套 if，这样代码 review 很费力很费力。 if (a) { if (b) { if (c) { // 需要执行的方法A(缩进太多，review起来真费劲 o(╥﹏╥)o ) } } } if (!a || !b || !c) { return; } // 需要执行的方法A(没缩进，review起来真舒服 ^_^ ) 正确性 不要用 any 类型 众所周知，js 是灵活的弱类型语言，我们永远无法确定一个变量的实际类型，这在开发的时候也就造成了一定的“恐慌”，比如： if (typeof a === \"string\") if (Array.isArray(a) && a.length > 0) if (a) if (!a) if (a != NaN) 自从 ts 出现以后，一切都变得奇迹。ts 具有类型系统，且是 js 的超集。比如，我用 ts 定义了一个变量是 string 类型，那么就不能把 number 类型的值赋值给他。但是，ts 也有一个漏洞，就是 any 类型，比如下面这个例子。 const anyThing:any = { name: string age?: number } 虽然 name 是 string 类型，但是 anyThing 不是啊，这个就尴尬了，这样的话，name 是有可能为任何值的。所以，尽量少用 any（除非迫不得己）。因为每增加一个 any，代码就增加了一份风险和恐慌。 变量定义的使用顺序 const > let，减少使用 var js 有一个很恐怖的事情就是“变量提升”，就是 js 引擎在解析代码的时候，先把 var 定义和函数定义提到最前面去，这就是所谓的“变量提升”和“函数提升”。而且，var 是全局变量，看下面一个经典的错误案例。 var a = 99; // 全局变量a f(); // f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 console.log(a); // a=>99, 此时是全局变量的a function f() { console.log(a); // 当前的a变量是下面变量a声明提升后，默认值undefined var a = 10; console.log(a); // a => 10，这个a是上一行赋值的 } let 和 const 是 ES6 新增的定义类型 let 是不会变量提升的，而且有暂时性死区。也就是 let 必须先声明，后面的代码才能够使用，否则 Uncaught ReferenceError 错误。 const 只能够初始化赋值，相当于是定义一个常量，但是 const 定义的常量对于数组和对象无法控制。 命名规范 文件命名 对于文件，由于早期 Windows 操作系统不区分文件名大小写，所以文件尽可能以小写形式命名，多个单词中间使用连字符“-”连接。 变量命名 变量命名全部采用“小驼峰式(lowerCamelCase)”。当一段代码很长的时候要把它拆分然后用函数或变量给予有意义的名称。我们人脑喜欢看人类语言，而不是程序语言。所以我们写的代码要尽可能像英语，而不是编程语言。 命名时要注意动词、名词和形容词的区分。动词来代表一个指令动作，名词代表一个对象名称，形容词来表示一个状态（往往是 boolean 或 enum）。一般来说，函数命名使用动词形式，变量命名使用名词或形容词形式。 举例： 动词：login addUser getUserInfo 名词：user 形容词：isUser 命名参考(Java) 类名：UpperCamelCase（大驼峰命名法） 方法名、参数名、局部变量名：lowerCamelCase（小驼峰命名法） 测试方法名、常量(全局)、枚举名称：SNAKE_CASE（蛇形命名法） 文件夹名称：kebab-case（串式命名法） 开发工具和插件 Prettier 插件 function 后面是否加空格？ 括号是否要换行？ 结尾加分号还是不加分号？ 用单引号还是双引号？ 一千个程序员就会有一千种代码风格。当我们团队协作开发时候，我们要“舍弃”自己的特色，而统一风格，否则，对于其他开发人员来说，另类的代码风格是很不友好的体现。举一个简单的例子，下面三种代码风格，每一种都有自己的特色。 // 普通程序员 function main() { let a = 0, b = 1, c = 2; return 0; } // 文艺程序员 function main() { let a = 0; let b = 1; let c = 2; return 0; } // 2B程序员 function main() { let a = 0, b = 1, c = 2; return 0; } Prettier 就是用来帮助我们统一代码风格的工具。 "},"Chapter1/2.html":{"url":"Chapter1/2.html","title":"二、JS 进阶","keywords":"","body":"JS 进阶 面向对象编程 什么是对象？万物皆对象。 在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。 自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 面向过程 & 面向对象 我们以一个示例来说明两者区别。 我们需要处理学生成绩，将学生的成绩打印出来。 首先，面向过程编程的方式是这样的。 // 面向过程编程 // 1. 存储学生成绩信息 var std1 = { name: '张三', score: 98 }; var std2 = { name: '李四', score: 81 }; // 2. 输出学生成绩 function printScore(student) { console.log('姓名：' + student.name + ' ' + '成绩：' + student.score); } 面向对象编程，考虑的不是程序执行流程，而是 Student 这个对象有哪些属性和方法。 // 面向对象编程 // 1. 定义对象（类） function Student(name, score) { this.name = name; this.score = score; } Student.prototype.printScore = function () { console.log('姓名：' + this.name + ' ' + '成绩：' + this.score); }; // 2. 实例化对象 var std1 = new Student('张三', 98); var std2 = new Student('李四', 81); // 3. 输出学生成绩 std1.printScore(); // => 姓名：张三 成绩：98 std2.printScore(); // => 姓名：李四 成绩 81 如何创建对象 字面量方式 我们可以直接通过 new Object() 创建。 var person = new Object(); person.name = '张三'; person.age = 18; person.sayName = function () { console.log(this.name); }; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建。 var person = { name: '张三', age: 18, sayName: function () { console.log(this.name); }, }; 上面的写法是没有问题的，但是假如我们要生成两个 person 实例对象呢？ var person1 = { name: '张三', age: 18, sayName: function () { console.log(this.name); }, }; var person2 = { name: '李四', age: 16, sayName: function () { console.log(this.name); }, }; 工厂模式 function createPerson(name, age) { return { name: name, age: age, sayName: function () { console.log(this.name); }, }; } var p1 = createPerson('张三', 18); var p2 = createPerson('李四', 18); 这样封装比上边的方式好多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题， 但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数创建对象 创建对象的最佳实践方案，则是利用构造函数。 所谓的构造函数其实就是一个普通的函数前面加了 new 运算符，其实质也是一个函数，所以构造函数都有函数的 prototype 属性。 实例就是通过构造函数创建出来的对象。 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; } var p1 = new Person('张三', 18); p1.sayName(); // => 张三 var p2 = new Person('李四', 23); p2.sayName(); // => 李四 构造函数特点 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 构造函数执行步骤 使用 new 操作符创建一个新对象。 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）。 执行构造函数中的代码。 返回新对象。 // 伪代码演示 function Person(name, age) { // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = {} // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; // 在函数的结尾处会将 this 返回，也就是 instance // return this } 构造函数示例 function Person(name, age) { this.name = name; this.age = age; this.sayName = function () { console.log(this.name); }; } var p1 = new Person('张三', 18); p1.sayName(); // => 张三 var p2 = new Person('李四', 23); p2.sayName(); // => 李四 console.log(p1.constructor === Person); // 变量p1的构造器是Person，返回true console.log(p2.constructor === Person); // 变量p2的构造器是Person，返回true console.log(p1.constructor === p2.constructor); // 变量p1和p2的构造器相同 console.log(p1 instanceof Person); // 返回 true console.log(p2 instanceof Person); // 返回 true 上边的代码，从表面看上好像没什么问题，但是实际上这样做，有一个很大的弊端。 那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容， 每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 function Person(name, age) { this.name = name; this.age = age; this.type = '学生'; this.sayHello = function () { console.log('hello ' + this.name); }; } var p1 = new Person('王五', 18); var p2 = new Person('李四', 16); console.log(p1.sayHello === p2.sayHello); // => false 有什么好的解决办法呢？更好的解决方案就是 prototype。 Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。 这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 function Person(name, age) { this.name = name; this.age = age; } console.log(Person.prototype); // 返回 { constructor:{...}, _proto_:{...} } Person.prototype.type = '学生'; Person.prototype.sayName = function () { console.log(this.name); }; var p1 = new Person('王五', 18); var p2 = new Person('李四', 16); console.log(p1.sayName === p2.sayName); // => true 这时所有实例的 type 属性和 sayName() 方法， 其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 原型和原型链 原型 原型的作用：数据共享、节省内存。 所谓的构造函数其实就是一个普通的函数前面加了 new 运算符，其实质也是一个函数，所以构造函数都有函数的 prototype 属性。实例就是通过构造函数创建出来的对象。 prototype 属性是一个指针，指向一个对象，这个对象就是原型对象。 至于是谁的原型对象，需要靠函数的 prototype 属性和实例的__proto__属性来确定。 原型对象上默认有一个属性 constructor,该属性也是一个指针，指向其相关联的构造函数。 function People() { this.type = '人'; } People.prototype.showType = function () { console.log(this.type); }; var person = new People(); //调用原型对象上面的方法 person.showType(); //最后结果弹框弹出人 People.prototype.constructor == People; //返回true [!note] 构造函数的 prototype 是指针，指向的是原型对象。 原型对象的 constructor 也是指针，指向的是构造函数。 实例的_proto_指针也指向原型对象。 原型链 从实例开始，实例的_proto_指针指向原型对象，原型对象也存在_proto_指针指向上一层的原型对象。后面也以此类推，一直到 Object.prototype 这个原型为止，Object.prototype 为原型链的末尾点。 function People() { this.name = 'Jane'; } var person = new People(); [!note] person 实例的_proto_属性指向原型对象 原型对象的_proto_指向上一层 Object 原型对象。 Object 原型对象的构造函数是 Object，为该原型链的末端。 instanceof 的原理 instanceof 可以判断实例对象的_proto_属性是否与构造函数的 prototype 属性指向同一地址，是的话返回 true，否则 fasle。 // 实例 instanceof 构造函数 person instanceof People; constructor 构造器 实例的_proto_属性找到原型对象，原型对象的 constructor 属性找到构造函数。 person._proto_.constructor == People; 更简单的原型语法 function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { type: '学生', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了'); }, }; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。 这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： function Person(name, age) { this.name = name; this.age = age; } Person.prototype = { constructor: Person, // => 手动将 constructor 指向正确的构造函数 type: '学生', sayHello: function () { console.log('我叫' + this.name + '，我今年' + this.age + '岁了'); }, }; 原生对象(String/Array...)的原型 // 为内置对象添加原型方法 // 我们在系统的对象的原型中添加方法,相当于在改变源码 // 我希望字符串中有一个倒序字符串的方法 String.prototype.myReverse = function () { for (var i = this.length - 1; i >= 0; i--) { console.log(this[i]); } }; var str = 'abcdefg'; str.myReverse(); // 为Array内置对象的原型对象中添加方法 Array.prototype.mySort = function () { for (var i = 0; i 继承 继承是一种类(class)与类之间的关系,JS 中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承，继承是为了实现数据共享，js 中的继承当然也是为了实现数据共享。 原型继承 function Person(name, age, sex, weight) { this.name = name; this.age = age; this.sex = sex; this.weight = weight; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(score) { this.score = score; } //希望人的类别中的数据可以共享给学生---继承 Student.prototype = new Person('小三', 18, '男', '58kg'); var stu1 = new Student('99'); console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score); stu1.sayHi(); var stu2 = new Student('89'); console.log(stu2.name, stu2.age, stu2.sex, stu2.weight, stu2.score); stu2.sayHi(); var stu3 = new Student('66'); console.log(stu3.name, stu3.age, stu3.sex, stu3.weight, stu3.score); stu3.sayHi(); 构造函数继承 在上边的讲解中，我们为了数据共享,改变了原型指向,做到了继承，即通过改变原型指向实现了继承。这导致了一个问题，因为我们改变原型指向的同时,直接初始化了属性，这样继承过来的属性的值都是一样的了。这是个问题，如果我们想要改变继承过来的值，只能重新调用对象的属性进行重新赋值，这又导致我们上边的初始化失去了意义。 如何解决上边的问题呢？答案是借用构造函数实现继承。 继承的时候,不改变原型的指向,直接调用父级的构造函数来为属性赋值，即把要继承的父级的构造函数拿过来,借用一下为属性赋值，这叫做借用构造函数。借用构造函数需要使用 call ()这个方法，我会在后边的文章中进行讲解，大家在这里先记住用法就行了。 function Person(name, age, sex, weight) { this.name = name; this.age = age; this.sex = sex; this.weight = weight; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(name, age, sex, weight, score) { // ☆☆☆ 借用构造函数 ☆☆☆ Person.call(this, name, age, sex, weight); this.score = score; } var stu1 = new Student('小三', 16, '男', '50kg', '110'); console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score); var stu2 = new Student('小红', 22, '女', '45kg', '88'); console.log(stu2.name, stu2.age, stu2.sex, stu2.weight, stu2.score); var stu3 = new Student('小舞', 16, '女', '40kg', '100'); console.log(stu3.name, stu3.age, stu3.sex, stu3.weight, stu3.score); 借用构造函数继承,解决了继承的时候属性重复的问题。但是这又导致一个问题即父类中的原型方法不能被继承。 组合继承 原型继承和借用构造函数继承都存在各自的缺点，我们可以将这二者结合到一起，从而发挥二者之长。即在继承过程中，既可以保证每个实例都有它自己的属性，又能做到对一些属性和方法的复用。 这时组合继承应运而生，组合继承=原型继承+构造函数继承。 function Person(name, age, sex) { this.name = name; this.age = age; this.sex = sex; } Person.prototype.sayHi = function () { console.log('你好帅呀!!!'); }; function Student(name, age, sex, score) { //借用构造函数:解决属性值重复的问题 Person.call(this, name, age, sex); this.score = score; } //改变原型指向---原型继承解决原型方法不能被继承问题 Student.prototype = new Person(); //不传值 Student.prototype.eat = function () { console.log('吃吃吃!!!'); }; var stu = new Student('小三', 16, '男', '111分'); console.log(stu.name, stu.age, stu.sex, stu.score); stu.sayHi(); stu.eat(); var stu2 = new Student('小舞', 15, '女', '1111分'); console.log(stu2.name, stu2.age, stu2.sex, stu2.score); stu2.sayHi(); stu2.eat(); 拷贝继承（for-in） 拷贝继承：把一个对象中的属性或者方法直接复制到另一个对象中。 function Person() {} Person.prototype.name = '小三'; Person.prototype.age = 18; Person.prototype.sex = '男'; Person.prototype.height = 100; Person.prototype.play = function () { console.log('玩的好开心呀!!!😃'); }; var obj = {}; // Person中有原型prototype,prototype就是一个对象,那么里面,name,age,sex,height,play都是该对象中的属性或者方法 // 新对象obj通过拷贝Person中原型prototype对象中的属性和方法继承Person中原型prototype对象的属性和方法 for (var key in Person.prototype) { obj[key] = Person.prototype[key]; } console.dir(obj); obj.play(); [!note] 原型链是一种关系,是实例对象和原型对象之间的关系,这种关系是通过原型(proto)来联系的。继承是类与类之间的关系，js 不是面向对象的语言，没有类但可以通过函数模拟类，模拟面向对象中的继承。模拟继承是为了实现数据共享，节省内存空间。 JS 中的继承方式: 原型继承:通过改变原型的指向实现继承。 借用构造函数继承:主要解决属性重复的问题，会导致父类中的原型方法不能继承。 组合继承:原型继承+借用构造函数继承，既能解决属性重复问题,又能解决方法不能被继承的问题。 拷贝继承:把对象中需要共享的属性或方法,直接通过遍历的方式复制到另一个对象中。 函数 函数声明 直接声明 变量声明 Function 构造函数创建实例（❌） // 直接声明 function fn() { console.log('我是JS中的一等公民-函数!!!哈哈'); } fn(); // 变量声明 var fn = function () { console.log('我是JS中的一等公民-函数!!!哈哈'); }; fn(); // Function构造函数创建实例 // new Function(arg1,arg2,arg3..,函数体); var f1 = new Function('num1', 'num2', 'return num1+num2'); console.log(f1(10, 20)); console.log(f1.__proto__ == Function.prototype); // 所以,函数实际上也是对象 console.dir(f1); console.dir(Function); 函数调用 普通函数 构造函数 对象方法 // 普通函数 function f1() { console.log('我是普通函数'); } f1(); // 构造函数---通过new 来调用,创建对象 function F1() { console.log('我是构造函数'); } var f = new F1(); // 对象的方法 function Person() { this.play = function () { console.log('我是对象中的方法'); }; } var per = new Person(); per.play(); this 指向 函数的调用方式决定了 this 指向的不同 调用方式 浏览器 Node.js 全局 this window {} 实际是 module 函数中的 this window 全局 global 构造函数中的 this 实例 实例 定时器函数 window Timeout // 普通函数 function f1() { console.log(this); // window | 严格模式下undefined } f1(); // 构造函数 function Person() { console.log(this); // Person // 对象的方法 this.sayHi = function () { console.log(this); // Person }; } // 定时器中的this setInterval(function () { console.log(this); // window }, 1000); call 和 apply call()和apply()作为函数调用，可以改变 this 的指向。 [!note] call( 指定this, [参数数组] ) apply( 指定this, 参数1, 参数2 ... ) function Person(name, sex) { this.name = name; this.sex = sex; } //通过原型添加方法 Person.prototype.sayHi = function (x, y) { console.log('您好啊:' + this.name); return x + y; }; var per = new Person('小丽', '男'); var r1 = per.sayHi(10, 20); // 构造函数的this，为实例per function Student(name, age) { this.name = name; this.age = age; } var stu = new Student('小王', 18); var r2 = per.sayHi.apply(stu, [10, 20]); // this指向stu var r3 = per.sayHi.call(stu, 10, 20); // this指向stu console.log(r1); console.log(r2); console.log(r3); 如果想使用别的对象的方法，并且希望这个方法是当前对象的，就可以使用 apply 或者是 call 方法改变 this 的指向。 bind bind()方法是绑定的意思，本质是创建一个新函数（成为”绑定函数“），参数可以在复制的时候传进去，也可以在复制之后调用的时候传入进去。 bind()方法，是复制一份的时候，改变了 this 的指向。 function Person(name) { this.name = name; } Person.prototype.play = function () { console.log(this + '====>' + this.name); }; function Student(name) { this.name = name; } var per = new Person('人'); var stu = new Student('学生'); per.play(); // 复制了一个新的play方法 var ff = per.play.bind(stu); ff(); [!note] 函数是对象，对象不一定是函数。 对象中有_proto_属性，函数中有 prototype 属性。 apply，call，bind 方法是用来改变 this 指向的。 apply 和 call 是调用方法的时候改变 this 指向。 bind 方法是创建一个新的函数的时候改变 this 的指向。 内存 内存存储 JS 分为两种类型，基本类型和引用类型。 基本类型 引用类型 ● 字符串 String● 数字 Number● 布尔 Boolean● 对空 Null● 未定义 Undefined●Symbol ● 对象 Object● 数组 Array● 函数 Function● 日期 Date● 正则 RegExp 栈内存和堆内存 栈内存：存储基本类型的变量值和引用类型的变量值地址。 堆内存：存储引用类型的变量值。 const num = 1; const obj = { key: 'val', }; num = 2; // TypeError: Assignment to constant variable. obj.key = 'val1'; // 赋值成功 num 和 null_val 两个变量都是基本类型，所以，直接在栈内存中存储值。 obj 是引用类型，在栈内存中存储地址，堆内存中存储值。 [!tip] null 虽然是 object 类型，但是仍然存储在栈内存中。 obj 虽然是 const 定义，但是其存储的是指针地址，这个地址不可以改变，但是地址对应的堆内存中的数据，是可以改变的。所以 obj.key 仍然可以改变其值。 所以，const 定义的变量其值不可以改变这个说法不准确。 new 定义的基本类型 new 一个构造函数，构造函数生成一个实例，这个实例是一个对象。 JS 提供了一些基本类型的构造函数，比如，String\\Number 等，那么这些 new 出来的变量和正常定义的变量有何不同呢？ 虽然，他们表面上看起来没什么区别，实际上内部完全不同。 new 出来的变量是一个对象，对象就是引用类型，栈内存中存储的是地址。 正常定义的变量就是一个基本类型变量，栈内存中存储的是变量值。 const str1 = 'hello'; const str2 = new String('hello'); const str3 = new String('hello'); console.log(str1 == str2); // true console.log(str2 == str3); // false console.log(str1 === str2); // false str1 和 str2 虽然表面一样，但是类型不同，所以弱等于（==）是相等的，强等于（===）是不等的。 str2 和 str3 虽然都是 object，但是是通过 new 出来的，他们都是对象，那么存储的就是地址。所以，str2 的地址不等于 str3 的地址。 [!danger] 不建议大家使用 new 来定义基本类型。 深拷贝 & 浅拷贝 不同类型的复制变量值的方式是不同的。对于基本类型，从一个变量向另外一个新变量复制基本类型的值，会创建这个值的一个副本，并将该副本复制给新变量。对于引用类型，从一个变量向另一个新变量复制引用类型的值，其实复制的是指针，最终两个变量都指向同一个对象。 浅拷贝 浅拷贝就是直接复制，相当于把一个对象中的所有的内容，复制一份给另一个对象，对于基本类型复制的是具体的值的副本，对于引用类型复制的是指针。 const obj1 = { key: 'val' }; const obj2 = obj1; // 浅拷贝，obj1和obj2的值会互相影响 深拷贝 深拷贝还是复制，对于基本类型复制的是具体的值的副本，对于引用类型会找到对象中具体的属性或者方法，并且开辟新的相应的空间，一个一个的复制到另一个对象中，在这个过程中需要使用递归。 function deepCopy = { // ...... } const obj1 = { key: 'val' }; const obj2 = deepCopy(obj1); // 深拷贝 深拷贝实现 第三方库 浏览器端使用 jQuery.extend 实现。 Node.js 环境使用 lodash 库实现。 // 浏览器 jQuery.extend $.extend(true, object1, object2); // 深度拷贝 $.extend(object1, object2); // 浅拷贝 // Node.js环境 lodash 库 var objects = [{ a: 1 }, { b: 2 }]; var deep = _.cloneDeep(objects); console.log(deep[0] === objects[0]); // => false JSON 对象 如果是一个 Object 对象或数组实现深拷贝，可以用JSON.stringify()和JSON.parse()来实现深拷贝。 var obj1 = { name: 'shen', }; var obj2 = JSON.parse(JSON.stringify(obj1)); obj2.name = 'shenzhiyong'; console.log('obj1:', obj1); // obj1: {name: \"shen\"} console.log('obj2:', obj2); // obj2: {name: \"shenzhiyong\"} 如果对象中有函数，则该方法不可用。 var obj1 = { name: 'shen', show: function (argument) { console.log(1); }, }; var obj2 = JSON.parse(JSON.stringify(obj1)); console.log('obj1:', obj1); // obj1: {name: \"shen\", show: ƒ} console.log('obj2:', obj2); // obj2: {name: \"shen\"} // show没有拷贝过来 递归实现 递归简单的来说就是程序自己调用自己，就像下面这幅图一样，一直循环往复。 就像我们经常听到的小和尚的故事，从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：从前有座山，山里有座庙，庙里...... JavaScript 的递归就是在函数中调用函数自己。 // 递归:函数中调用函数自己 function f1() { console.log( '从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：' ); f1(); // 调用自己 } f1(); 如果程序一直这样循环往复的调用自己，一直都不结束，就是一个死循环，这没什么意义。 所以我们需要为递归定义一个结束条件，即递归的出口，当条件不满足时，递归一直前进，不断地调用自己；当边界条件满足时，递归返回。 // 递归的结束条件为i大于5 var i = 0; function f1() { i++; if (i > 5) { return; // 出口 } console.log( '从前有座山，山里有座庙，庙里有个老和尚和一个小和尚，有一天老和尚对小和尚讲故事，故事内容是：' ); f1(); } f1(); 递归深拷贝代码 function deepCopy(obj) { // 简单类型 或 null 直接返回 if (typeof obj !== 'object' || obj === null) { return obj; } const newObj = obj.constructor === Array ? [] : {}; // 循环 obj 的属性/元素 for (const key in obj) { const val = obj[key]; if (typeof val !== 'object' || val === null) { newObj[key] = val; } else { newObj[key] = deepCopy(val); } } return newObj; } var obj1 = { name: 'shen', show: function () { console.log('hello world'); }, }; var obj2 = deepCopy(obj1); console.log('obj1:', obj1); // obj1: { name: 'shen', show: [Function: show] } console.log('obj2:', obj2); // obj2: { name: 'shen', show: [Function: show] } 闭包 作用域 变量分为全局变量和局部变量。作用域也就是变量的使用范围，分为全局作用域和局部作用域。 局部变量的使用范围为局部作用域，全局变量的使用范围是全局作用域。 在 ES6 引入了let定义变量后，也增加了一个块级作用域。 作用域链 内部函数访问外部函数的变量时，采用的是链式查找的方式。从里向外搜索，如果中间搜到了就使用，搜到 0 级作用域还没有搜到则报错，这个过程就是作用域链。 // 作用域链:变量的使用,从里向外,层层的搜索,搜索到了就直接使用 // 搜索到0级作用域的时候,如果还是没有找到这个变量,就会报错 const num1 = 10; //作用域链 function f1() { const num2 = 20; function f2() { const num3 = 30; console.log(num1); // >10 } f2(); } f1(); 预解析 JS 代码在浏览器中是由 JS 引擎进行解析执行的，分为两步，预解析和代码执行。 预解析分为 变量预解析（变量提升） 和 函数预解析（函数提升），浏览器 JS 代码运行之前，会把变量的声明和函数的声明提前(提升)到该作用域的最上面。 变量预解析 把所有变量的声明提升到当前作用域的最前面，不提升赋值操作。 下面是预解析前编写的代码。 // 原始代码 console.log(num); // 没有报错，返回的是一个undefined var num = 666; 预解析后，num 变量声明提升到最前面，但是赋值操作仍在后面。 // 预解析后：变量提升 var num; console.log(num); // 所以返回的是一个undefined num = 666; 函数预解析 将所有函数声明提升到当前作用域的最前面。 下面是预解析前编写的代码。 // 原始代码 f1(); // 能够正常调用 function f1() { console.log('Albert唱歌太好听了'); } 预解析后，函数声明提升到最前面。 function f1() { console.log('Albert唱歌太好听了'); } f1(); //预解析后，代码是逐行执行的，执行到 f1()后，去调用函数 f1（） 闭包 官方说法：JS 的闭包是指一个函数与周围状态（词法环境）的引用捆绑在一起（封闭）的组合，在 JS 中，每次创建函数时，都会同时创建闭包。闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰，即形成一个不销毁的栈环境。 通俗的将，就是父函数中包含一个子函数，子函数可以调用父函数中的变量。 闭包示例 1 function parent() { let x = 0; function children() { return ++x; } return children; // 返回children函数 } let children = parent(); // 创建children函数 console.log(children()); // 1 console.log(children()); // 2 console.log(children()); // 3 console.log(children()); // 4 // 创建新的children函数 children = parent(); console.log(children()); // 1 闭包示例 2 // 普通的函数 function f1() { let num = 0; num++; return num; } // 每次执行f1, num都是重新定义，并且初始化为0 console.log(f1()); // 1 console.log(f1()); // 1 console.log(f1()); // 1 // 闭包 function f2() { let num = 0; return function () { num++; return num; }; } var ff = f2(); // ff = function() { num++; return num; } // num 本来在 f2的作用域中，但是 ff 也可以调用，破坏了 num 的作用域。 console.log(ff()); // 1 console.log(ff()); // 2 console.log(ff()); // 3 闭包的作用 闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这显然类似于面向对象编程。在面向对象编程中，对象允许我们将某些数据（对象的属性）与一个或者多个方法相关联。 在一些编程语言中，比如 Java，是支持将方法声明为私有的(private)，即它们只能被同一个类中的其它方法所调用。而 JavaScript 没有这种原生支持，但我们可以使用闭包来模拟私有方法。 私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 下面我们计数器为例，代码如下。 // 闭包的作用 var myCounter = function () { var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function () { changeBy(1); }, decrement: function () { changeBy(-1); }, value: function () { return privateCounter; }, }; }; var Counter1 = myCounter(); var Counter2 = myCounter(); console.log(Counter1.value()); /* 计数器1现在为 0 */ Counter1.increment(); Counter1.increment(); console.log(Counter1.value()); /* 计数器1现在为 2 */ Counter1.decrement(); console.log(Counter1.value()); /* 计数器1现在为 1 */ console.log(Counter2.value()); /* 计数器2现在为 0 */ Counter2.increment(); console.log(Counter2.value()); /* 计数器2现在为 1 */ 在上边的代码中我们创建了一个匿名函数含两个私有项：名为 privateCounter 的变量和名为 changeBy 的函数。这两项都无法在这个匿名函数外部直接访问。必须通过匿名函数返回的三个公共函数访问，Counter.increment，Counter.decrement 和 Counter.value，这三个公共函数共享同一个环境的闭包，多亏 JavaScript 的词法作用域，它们都可以访问 privateCounter 变量和 changeBy 函数。我们把匿名函数储存在一个变量 myCounter 中，并用它来创建多个计数器，每次创建都会同时创建闭包，因为每个闭包都有它自己的词法环境，每个闭包都是引用自己词法作用域内的变量 privateCounter ，所以两个计数器 Counter1 和 Counter2 是各自独立的。以这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。 闭包的危害 通常来说，函数的活动对象会随着执行期上下文一起销毁，但是，由于闭包引用另外一个函数的活动对象，因此这个活动对象无法被销毁，这意味着，闭包比一般的函数需要更多的内存消耗。 使用闭包时，会涉及到跨作用域访问，每次访问都会导致性能损失。 因此在脚本中，最好小心使用闭包，它同时会涉及到内存和速度问题。不过我们可以通过把跨作用域变量存储在局部变量中，然后直接访问局部变量，来减轻对执行速度的影响。 异步编程 JS 是单线程的，在浏览器中 js 的执行栈跟渲染线程是相互阻塞的。 单线程模式最大的优势就是更安全，更简单 缺点也很明确，就是如果中间有一个特别耗时的任务，其他的任务就要等待很长的时间，出现假死的情况。 为了解决这种问题，JS 有两种任务的执行模式：同步模式（Synchronous）和异步模式（Asynchronous）。 同步和异步 同步模式 Synchronous程序的执行顺序和代码的编写顺序是完全一致的。代码按顺序执行，后一个任务必须等前一个任务执行完才能执行。 一旦有任务卡住或执行较慢，则后续所有代码都会受到影响。 异步模式 Asynchronous 不会去等待这个任务的结束才开始下一个任务，都是开启过后就立即往后执行下一个任务。 耗时函数的后续逻辑会通过回调函数的方式定义，任务完成后，就会调用回调函数。 回调函数异步方案 回调函数由调用者定义，交给执行者执行的函数 // callback就是回调函数 // 就是把函数作为参数传递，缺点是不利于阅读，执行顺序混乱。 function foo(callback) { setTimeout(function () { callback(); }, 3000); } foo(function () { console.log('这就是一个回调函数'); console.log('调用者定义这个函数，执行者执行这个函数'); console.log('其实就是调用者告诉执行者异步任务结束后应该做什么'); }); Promise 异步方案 回调的多重嵌套，会导致代码可读低、编写费劲、容易出错，故而被称为 callback hell（回调地狱）。 为了避免这个问题。CommonJS 社区提出了 Promise 的规范，ES6 中称为语言规范。 [!note] Promise 并不算是真正的异步，只不过是回调函数的语法糖形式。 回调函数是横向拓展，而 Promise 将其转换成了竖向拓展。 Promise 是一个对象，用来表述一个异步任务执行之后是成功还是失败，它有多个状态： Pending 待定状态, 表示还不清楚异步执行的结果 是成功还是失败。 Fulfilled 完成状态, 表示操作已经完成 Rejected 操作失败 Promise 基本用法 const promise = new Promise((resolve, reject) => { if (true) resolve(100); else reject(new Error('promise rejected')); }); promise.then( (value) => { console.log('resolved', value); // 100 }, (error) => { console.log('rejected', error); // rejected Error: promise rejected } ); Promise 链式调用 promise 对象 then 方法，返回了全新的 promise 对象。可以再继续调用 then 方法，如果 return 的不是 promise 对象，而是一个值，那么这个值会作为 resolve 的值传递，如果没有值，默认是 undefined。 后面的 then 方法就是在为上一个 then 返回的 Promise 注册回调。 前面 then 方法中回调函数的返回值会作为后面 then 方法回调的参数。 如果回调中返回的是 Promise，那后面 then 方法的回调会等待它的结束。 // promise假设是一个Promise实例 // then中的回调return了一个Promise实例 promise .then(() => { return new Promise((resolve, reject) => { // some code resolve('实参A'); }); }) .then((接收实参A) => { // 作为上一个then中的回调; }); // then中回调return的不是promise实例 promise .then(() => { return 123; }) .then((val) => { console.log(val); // 123 }); Promise 异常处理 catch 函数来捕获异常。 如果 then 中没有传入第二个回调 那么异常会进入 catch 的回调处理。 promise 中如果有异常，都会调用 reject 方法，还可以使用.catch()。 使用.catch 方法更为常见，因为更加符合链式调用。 const promise = new Promise((resolve, rejcet) => { rejcet(new Error('Some Error.')); }); promise .then(() => { console.log('success'); }) .catch((error) => { console.log(error); // Error: Some Error. }); Promise 并行执行 Promise.all()：全部执行结束则返回。 const p1 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('1秒'); // 1秒后输出 resolve(1); }, 1000); }); const p2 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('2秒'); // 2秒后输出 resolve(2); }, 2000); }); const p3 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('3秒'); // 3秒后输出 resolve(3); }, 3000); }); Promise.all([p1, p2, p3]).then((values) => { console.log(values); // [1, 2, 3] }); Promise.race()：先结束的就直接返回。 const p1 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('1秒'); // 1秒后输出 resolve(1); }, 1000); }); const p2 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('2秒'); // 2秒后输出 resolve(2); }, 2000); }); const p3 = new Promise((resolve, rejcet) => { setTimeout(() => { console.log('3秒'); // 3秒后输出 resolve(3); }, 3000); }); Promise.race([p1, p2, p3]).then((values) => { console.log(values); // p1执行结束后就输出 1 }); Generator 异步方案 Generator 函数 Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 // Generator 函数定义 function* gen(x) { let y = yield x + 2; yield 5; return y; } // Generator 函数执行 let g = gen(1); // 内部指针（遍历器）g let res1 = g.next(); // 调用g的next，内部执行知道遇到yield语句 let res2 = g.next(); let res3 = g.next(); let res4 = g.next(); console.log('res1', res1); console.log('res2', res2); console.log('res3', res3); console.log('res4', res3); /** output res1 { value: 3, done: false } res2 { value: 5, done: false } res3 { value: undefined, done: true } res4 { value: undefined, done: true } */ 上面的函数就是一个 Generator 函数，他不同于普通函数，他是可以暂停的，所以 function 后面加*号，以示区别。 每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 整个 Generator 函数都是一个异步的容器，容器中需要暂停的地方都是用yield来注明。 数据交换和错误处理 Generator 函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 数据交换 next 方法返回值的 value 属性，是 Generator 函数向外输出数据；next 方法还可以接受参数，这是向 Generator 函数体内输入数据。 function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); console.log(g.next()); console.log(g.next(6)); /** output { value: 3, done: false } { value: 6, done: true } */ 上面代码中，第一个 next 方法的 value 属性，返回表达式 x + 2 的值（3）。第二个 next 方法带有参数 2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量 y 接收。因此，这一步的 value 属性，返回的就是 6（变量 y 的值）。 错误处理 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 function* gen(x) { try { var y = yield x + 2; } catch (e) { console.log(e); } return y; } var g = gen(1); console.log(g.next()); console.log(g.throw('抛出错误！')); /** output { value: 3, done: false } 抛出错误！ { value: undefined, done: true } */ 上面代码的最后一行，Generator 函数体外，使用指针对象的 throw 方法抛出的错误，可以被函数体内的 try ... catch 代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 async/await 异步方案 async/await 是 Generator 函数的语法糖形式。 async作为一个关键字放在函数的前面，表示该函数是一个异步函数，意味着该函数的执行不会阻塞后面代码的执行 异步函数的调用跟普通函数一样。 await就是 yeild 的功能，async 函数中的暂停。 async 函数返回的结果是一个 Promise 对象，要获取 Promise 的返回值应该用 then 方法。 async function timeout() { return 'hello world'; } timeout().then((result) => { console.log(result); }); console.log('我在异步函数后面，会先执行谁呢？'); /** output 我在异步函数后面，会先执行谁呢？ hello world */ 此时先输出的就是后面的一串文字，说明异步函数的执行没有阻塞后面的代码执行，async的内部实现原理就是如果该函数中有一个返回值，当调用该函数时，默认会在内部调用Promise.solve() 方法把它转化成一个Promise 对象作为返回，若函数内部抛出错误，则调用Promise.reject()返回一个Promise 对象。 正则表达式 正则表达式在各种编程语言中，都有广泛的应用。在 JavaScript 中更是不可或缺，正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文。 此外，正则表达式还常用于过滤掉页面内容中的一些敏感词(替换)，或从字符串中获取我们想要的特定部分(提取)等 。 本文从正则表达式的基本概念入手，讲解了正则表达式的特点和组成，并且详细讲解了正则表达式在 JavaScript 中的使用，并给出了一些在实际开发中经常用到的实例。 什么是正则表达式 正则表达式是用于匹配规律规则的表达式，它的“鼻祖”可一直追溯到科学家对人类神经系统的工作原理的早期研究。现在在各种编程语言中，正则表达式都有广泛的应用。在 JavaScript 中，正则表达式也是对象，正则表通常被用来检索、替换那些符合某个模式(规则)的文本。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配)。 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取)。 强大的字符串替换能力(替换)。 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \\d 匹配数字 ab\\d 匹配 ab1、ab2 元字符串 常用元字符串 元字符 说明 \\d 匹配数字 \\D 匹配任意非数字的字符 \\w 匹配字母或数字或下划线 \\W 匹配任意不是字母，数字，下划线 \\s 匹配任意的空白符 \\S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复 n 次 {n,} 重复 n 次或更多次 {n,m} 重复 n 到 m 次 其它符号 符号 说明 [] 字符串用中括号括起来，表示匹配其中的任一字符。 匹配中括号以外的内容，相当于”非“的意思 \\ 转义符 \\ 选择两者中的一个，相当于”或者“ () 从两个直接量中选择一个，分组。 例如：gr(a\\ e)y 匹配 gray 和 grey。 [\\u4e00-\\u9fa5] 匹配汉字 常用的正则表达式 // 验证手机号是否11位 /^\\d{11}$/ /^1[3-9]\\d{9}$/ // 验证邮编 /^\\d{6}$/ // 验证日期 yyyy-mm-dd /^\\d{4}-\\d{1,2}-\\d{1,2}$/ // 验证邮箱 /^[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_-]+([.][a-zA-Z]+){1,2}$/ // 验证IP地址 xxx.xxx.xxx.xxx /^\\d{1,3}\\(.\\d{1,3}){3}$/ // 验证中文 /^[\\u4e00-\\u9fa5]{2,6}$/ // 验证身份证 /^[1-9]\\d{5}(18|19|20|(3\\d))\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$/ "},"Chapter6/":{"url":"Chapter6/","title":"第六章 Mysql 存储","keywords":"","body":" Mysql 安装和配置 "},"Chapter6/1.html":{"url":"Chapter6/1.html","title":"Mysql 安装和配置","keywords":"","body":"Mysql 存储 一、安装 Mysql 1、删除存在的 mysql rpm -qa|grep mysql rpm -e mysql mysql-libs yum -y remove mysql-server mysql mysql-libs 2、配置源 # 下载rpm软件包管理器 wget http://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm # 配置源 rpm -ivh mysql57-community-release-el7-9.noarch.rpm # 查看源是否配置 yum repolist enabled | grep \"mysql.*-community.*\" 3、安装 Mysql 注意，默认安装源之后自动开启 5.7 系列的安装。如果你要安装的 MySQL 低于 5.7 需要改源。。 # 安装社区版 yum install mysql-community-server 二、启动 Mysql 1、执行启动命令 # 启动mysql service mysqld start 2、其他命令 # 查看启动状态 service mysqld status # 重启 service mysqld restart # 停止 service mysqld stop 三、权限配置 1、修改密码 Mysql 首次启动会，会生成一个临时密码，通过命令来查看。 grep 'temporary password' /var/log/mysqld.log 可以看到，临时密码是“k+)!R(VPs3F+”。 2、使用临时密码进入 mysql 服务 # root账户登录 mysql -uroot -p # 输入密码 k+)!R(VPs3F+ 3、重置密码 进入数据库后，在执行操作前，必须重置密码。 # 查看数据库 show databases; 设置密码。 # 设置密码 set password = password('8位密码，包括大写、小写、数字和特殊符号'); 4、查看用户 # 切换到mysql数据库 use mysql; # 查看user表信息 select host,user from mysql.user; 5、添加新用户和数据库 # 添加新用户，允许外网访问 create user 'aquaman'@'%' identified by '密码'; # 添加成功后，刷新授权 flush privileges; # 创建数据库 create database aquaman DEFAULT CHARSET utf8 COLLATE utf8_general_ci; # 将改用户赋权给数据库，并刷新授权 grant all privileges on aquaman.* to 'aquaman'@'%' identified by '密码' with grant option; # 刷新授权 flush privileges; # 更改用户名 update user set user ='aquaman' where user ='nodejs'; 本地即可连接 Mysql 数据库，连接成功后，只能够有权限管理 nodejs 库，其他库无法查看。 补充 rpm 是一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。 # 配置源 rpm -i xxx.rpm # 删除配置 rpm -e mysql80-community-release-el8-1.noarch "},"Chapter7/":{"url":"Chapter7/","title":"第七章 Mongodb 存储","keywords":"","body":" Mongodb安装和配置 "},"Chapter7/1.html":{"url":"Chapter7/1.html","title":"Mongodb 安装和配置","keywords":"","body":"Mongodb安装和配置 一、安装Mongodb 在这个MongoDB教程中，我们将解释如何在CentOS 7上安装数据库，然后提供一些基本特性和功能的简短指南。 1、添加MongoDB源 CentOS7不包括Mongodb源，所以需要自行添加。 # 创建文件 vi /etc/yum.repos.d/mongodb-org-4.2.repo 2、复制下面内容到文件中 [mongodb-org-4.2] name=MongoDB Repository baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/ gpgcheck=1 enabled=1 gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc 3、执行安装 # yum安装 yum install -y mongodb-org 二、配置Mongodb配置 1、修改配置文件的 bind_ip, 默认是 127.0.0.1 只限于本机连接。 # 编辑配置文件 vi /etc/mongod.conf # 更改bind_ip bind_ip 0.0.0.0; # 0.0.0.0任何IP均可访问（为方便开发，生产环境无用！！！） # 查看版本号 mongod --version 三、权限 mongodb 操作前，先use 数据库，选择对应的数据库，然后 db.auth(\"admin\", \"密码\")才能够进行操作。 # 进入mongo mongo # 切换到admin库 use admin # 创建用户（role角色很多种） db.createUser({ user: \"admin\", pwd: \"密码\", roles: [{ role: \"dbOwner\", db: \"admin\" }] }) # 验证 db.auth(\"admin\", \"密码\") # 给用户赋予角色 db.grantRolesToUser(\"admin\", [ { role:\"dbAdminAnyDatabase\", db:\"admin\"} ]); # 回收用户角色 db.revokeRolesFromUser(\"admin\", [ { role:\"dbAdminAnyDatabase\", db:\"admin\"} ]); # 更改用户密码 db.changeUserPassword('admin','aD0aG1aA1eB2fA2l'); 四、常用命令 # 启动 service mongod start # Redirecting to /bin/systemctl start mongod.service # 所以，可以直接用 systemctl 命令 mongod.service 格式来执行各种命令 # 停止 service mongod stop # 重启 service mongod restart # 设置开机启动 chkconfig mongod on # 查看日志（日志文件地址为config配置） cat /var/log/mongodb/mongod.log # 开启外网访问权限 mongod --bind_ip_all # 进入mongo数据库 mongo # 查看数据库 show dbs; # 查看数据库版本 db.version(); # 常用命令帮助 db.help(); "},"Chapter8/":{"url":"Chapter8/","title":"第八章 Redis 存储","keywords":"","body":" Redis安装和配置 "},"Chapter8/1.html":{"url":"Chapter8/1.html","title":"Redis 安装和配置","keywords":"","body":"Redis存储 一、安装Redis 在本节中，您将添加EPEL存储库，然后使用它来安装Redis。 1、添加EPEL存储库，并更新YUM以确认您的更改 # 安装EPEL存储库 yum install epel-release # 安装redis yum install redis 2、启动redis # 启动服务 systemctl start redis # 验证redis是否启动，返回PONG表示启动 redis-cli ping # 重启服务 systemctl restart redis 二、配置Redis Redis 的配置文件位于 Redis 安装目录下，文件名为 redis.conf。 # 查看redis安装包 rpm -qa|grep redis # 找redis安装位置 rpm -ql redis-3.2.10-2.el7.x86_64 发现，redis.conf文件在/etc目录下。 # 查看所有配置 CONFIG GET * # 查看某一配置 CONFIG GET 配置名 # 编辑配置 CONFIG set 配置名 配置值 三、Redis命令 # 启动redis客户端 redis-cli # 授权 auth 密码 # 检查是否启动 PING # 存值 set foo bar # 取值 get foo "}}